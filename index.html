<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <meta name="theme-color" content="#0a1628">
    <meta name="description" content="Zenquarium - A meditative aquarium experience">
    <title>Zenquarium</title>
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <style>
/* ============================================
   ZENQUARIUM - Premium Aquarium PWA Styles
   ============================================ */

:root {
    /* Default theme (Koi Garden) */
    --water-top: #1a3a5c;
    --water-bottom: #0a1628;
    --water-mid: #12294a;
    --accent: #e8845c;
    --accent-glow: rgba(232, 132, 92, 0.3);
    --text-primary: #e8dcc8;
    --text-secondary: rgba(232, 220, 200, 0.6);
    --hud-bg: rgba(10, 22, 40, 0.85);
    --hud-border: rgba(232, 220, 200, 0.15);
    --btn-bg: rgba(10, 22, 40, 0.9);
    --btn-hover: rgba(30, 50, 80, 0.9);
    --sand: #2a1f14;
    --sand-light: #3d2e1f;
    --plant-primary: #2d5a3a;
    --plant-secondary: #1a3d28;
    --surface-color: rgba(255, 255, 255, 0.08);
    --caustic-color: rgba(255, 255, 255, 0.1);
}

* { margin: 0; padding: 0; box-sizing: border-box; }

html, body {
    width: 100%; height: 100%;
    overflow: hidden;
    background: #000;
    font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
    color: var(--text-primary);
    user-select: none;
    -webkit-user-select: none;
}

/* ============================================
   SPLASH SCREEN
   ============================================ */

.splash-screen {
    position: fixed; inset: 0;
    background: linear-gradient(180deg, #0d1b2a 0%, #1b2838 40%, #0a1628 100%);
    display: flex; align-items: center; justify-content: center;
    z-index: 1000;
    transition: opacity 1s ease, transform 1s ease;
}

.splash-screen.fade-out {
    opacity: 0;
    transform: scale(1.05);
    pointer-events: none;
}

.splash-content {
    text-align: center;
    max-width: 700px;
    padding: 40px;
    position: relative;
}

.splash-title h1 {
    font-size: 4rem;
    font-weight: 300;
    letter-spacing: 0.3em;
    text-transform: uppercase;
    background: linear-gradient(135deg, #e8dcc8 0%, #c9a96e 50%, #e8dcc8 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    animation: titleShimmer 4s ease-in-out infinite;
    margin-bottom: 8px;
}

@keyframes titleShimmer {
    0%, 100% { filter: brightness(1); }
    50% { filter: brightness(1.2); }
}

.splash-subtitle {
    font-size: 1rem;
    font-weight: 300;
    letter-spacing: 0.2em;
    color: var(--text-secondary);
    margin-bottom: 48px;
}

.splash-bubbles {
    position: absolute;
    inset: 0;
    pointer-events: none;
    overflow: hidden;
}

.splash-bubble {
    position: absolute;
    border-radius: 50%;
    background: radial-gradient(circle at 35% 35%, rgba(255,255,255,0.3), rgba(255,255,255,0.05));
    animation: splashBubbleRise linear infinite;
}

@keyframes splashBubbleRise {
    0% { transform: translateY(100%) scale(0.5); opacity: 0; }
    10% { opacity: 0.6; }
    90% { opacity: 0.3; }
    100% { transform: translateY(-100vh) scale(1); opacity: 0; }
}

/* Splash screen kelp */
.splash-seaweed {
    position: absolute;
    bottom: 0;
    width: 100px;
    height: 100%;
    pointer-events: none;
    overflow: visible;
    z-index: 0;
}

.splash-seaweed-left {
    left: -70px;
}

.splash-seaweed-right {
    right: -70px;
}

.kelp-stipe {
    position: absolute;
    bottom: 0;
    width: 6px;
    border-radius: 3px 3px 0 0;
    transform-origin: bottom center;
    animation: kelpSway ease-in-out infinite alternate;
}

@keyframes kelpSway {
    0% { transform: rotate(-3deg) translateX(-2px); }
    25% { transform: rotate(1deg) translateX(1px); }
    50% { transform: rotate(-2deg) translateX(-1px); }
    75% { transform: rotate(2deg) translateX(2px); }
    100% { transform: rotate(-1deg) translateX(-1px); }
}

.kelp-blade {
    position: absolute;
    border-radius: 60% 40% 50% 50% / 50%;
    transform-origin: bottom center;
    animation: bladeSway ease-in-out infinite alternate;
}

.kelp-blade.left-blade {
    transform-origin: bottom right;
}

.kelp-blade.right-blade {
    transform-origin: bottom left;
}

@keyframes bladeSway {
    0% { transform: rotate(-12deg) scaleY(1); }
    30% { transform: rotate(4deg) scaleY(0.97); }
    60% { transform: rotate(-6deg) scaleY(1.02); }
    100% { transform: rotate(8deg) scaleY(0.98); }
}

.kelp-bulb {
    position: absolute;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    transform-origin: bottom center;
}

.theme-selection h2 {
    font-size: 1rem;
    font-weight: 400;
    letter-spacing: 0.15em;
    text-transform: uppercase;
    color: var(--text-secondary);
    margin-bottom: 20px;
}

.theme-cards {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    gap: 12px;
    margin-bottom: 32px;
}

.theme-card {
    position: relative;
    padding: 20px 12px;
    border-radius: 12px;
    border: 2px solid transparent;
    cursor: pointer;
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    overflow: hidden;
}

.theme-card::before {
    content: '';
    position: absolute; inset: 0;
    border-radius: 12px;
    opacity: 0.8;
    z-index: 0;
}

.theme-card > * { position: relative; z-index: 1; }

.theme-card:hover {
    transform: translateY(-4px);
    box-shadow: 0 8px 32px rgba(0,0,0,0.4);
}

.theme-card:active {
    transform: translateY(-1px) scale(0.97);
    transition-duration: 0.1s;
}

.theme-card.selected {
    border-color: var(--accent);
    box-shadow: 0 0 20px var(--accent-glow);
}

.theme-card-name {
    font-size: 0.85rem;
    font-weight: 500;
    letter-spacing: 0.1em;
    margin-bottom: 4px;
}

.theme-card-desc {
    font-size: 0.65rem;
    opacity: 0.7;
    line-height: 1.4;
}

.splash-footer {
    margin-top: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 12px;
}

.about-btn {
    background: transparent;
    border: 1px solid rgba(232, 220, 200, 0.2);
    border-radius: 20px;
    color: var(--text-secondary);
    padding: 8px 24px;
    font-size: 0.75rem;
    letter-spacing: 0.15em;
    text-transform: uppercase;
    cursor: pointer;
    transition: all 0.3s ease;
}

.about-btn:hover {
    border-color: rgba(232, 220, 200, 0.4);
    color: var(--text-primary);
    background: rgba(255,255,255,0.05);
}

.splash-mute-btn {
    background: transparent;
    border: 1px solid rgba(232, 220, 200, 0.2);
    border-radius: 50%;
    width: 36px; height: 36px;
    font-size: 1rem;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex; align-items: center; justify-content: center;
    padding: 0;
}

.splash-mute-btn:hover {
    border-color: rgba(232, 220, 200, 0.4);
    background: rgba(255,255,255,0.05);
}

/* Stats ribbon on splash */
.stats-ribbon {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 24px;
    margin: 12px 0 0;
    font-size: 0.7rem;
    letter-spacing: 0.08em;
    color: rgba(232, 220, 200, 0.45);
}

.stats-ribbon .stat-item {
    display: flex;
    align-items: center;
    gap: 5px;
}

.stats-ribbon .stat-icon {
    font-size: 0.85rem;
}

.stats-ribbon .stat-value {
    color: rgba(232, 220, 200, 0.65);
    font-weight: 400;
}

/* Session summary overlay */
.session-summary {
    position: fixed; inset: 0;
    background: rgba(0,0,0,0.85);
    display: flex; align-items: center; justify-content: center;
    z-index: 1200;
    backdrop-filter: blur(8px);
    opacity: 0;
    transition: opacity 0.6s ease;
    pointer-events: none;
}

.session-summary.visible {
    opacity: 1;
    pointer-events: auto;
}

.session-summary-content {
    text-align: center;
    max-width: 420px;
    padding: 40px;
}

.session-summary h2 {
    font-size: 1.8rem;
    font-weight: 200;
    letter-spacing: 0.15em;
    margin-bottom: 8px;
    color: var(--text-primary, #e8dcc8);
}

.defeat-cause {
    font-size: 0.85rem;
    color: #e08080;
    margin-bottom: 12px;
    font-weight: 300;
    letter-spacing: 0.05em;
}

.session-summary .high-score-badge {
    color: #c9a96e;
    font-size: 1rem;
    letter-spacing: 0.1em;
    margin-bottom: 16px;
    animation: shimmer 2s ease-in-out infinite;
}

.session-summary .summary-stats {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 12px;
    margin: 20px 0;
    text-align: left;
}

.session-summary .summary-stat {
    background: rgba(255,255,255,0.05);
    border: 1px solid rgba(255,255,255,0.08);
    border-radius: 8px;
    padding: 10px 14px;
}

.session-summary .summary-stat-label {
    font-size: 0.6rem;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    color: rgba(232, 220, 200, 0.5);
    display: block;
}

.session-summary .summary-stat-value {
    font-size: 1.1rem;
    font-weight: 300;
    color: rgba(232, 220, 200, 0.9);
}

.session-summary .summary-achievements {
    margin: 16px 0;
    font-size: 0.75rem;
    color: rgba(232, 220, 200, 0.6);
}

.session-summary .summary-achievements .achievement-earned {
    display: inline-block;
    background: rgba(201, 169, 110, 0.15);
    border: 1px solid rgba(201, 169, 110, 0.3);
    border-radius: 16px;
    padding: 4px 12px;
    margin: 4px;
    font-size: 0.7rem;
    color: #c9a96e;
}

.session-summary .summary-btn {
    background: transparent;
    border: 1px solid rgba(232, 220, 200, 0.3);
    border-radius: 20px;
    color: rgba(232, 220, 200, 0.8);
    padding: 10px 32px;
    font-size: 0.8rem;
    letter-spacing: 0.12em;
    text-transform: uppercase;
    cursor: pointer;
    transition: all 0.3s ease;
    margin-top: 12px;
}

.session-summary .summary-btn:hover {
    border-color: rgba(232, 220, 200, 0.5);
    color: var(--text-primary, #e8dcc8);
    background: rgba(255,255,255,0.05);
}

/* Achievements overlay */
.achievements-overlay {
    position: fixed; inset: 0;
    background: rgba(0,0,0,0.8);
    display: flex; align-items: center; justify-content: center;
    z-index: 1100;
    backdrop-filter: blur(6px);
    opacity: 0;
    transition: opacity 0.4s ease;
    pointer-events: none;
}

.achievements-overlay.visible {
    opacity: 1;
    pointer-events: auto;
}

.achievements-content {
    max-width: 520px;
    max-height: 80vh;
    overflow-y: auto;
    background: linear-gradient(180deg, rgba(20,30,50,0.95), rgba(10,18,38,0.98));
    border: 1px solid rgba(232, 220, 200, 0.12);
    border-radius: 16px;
    padding: 32px;
    text-align: center;
}

.achievements-content h2 {
    font-size: 1.4rem;
    font-weight: 200;
    letter-spacing: 0.2em;
    text-transform: uppercase;
    margin-bottom: 20px;
    color: #e8dcc8;
}

.achievements-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px;
    text-align: left;
}

.achievement-card {
    background: rgba(255,255,255,0.04);
    border: 1px solid rgba(255,255,255,0.08);
    border-radius: 10px;
    padding: 12px;
    transition: all 0.3s ease;
}

.achievement-card.unlocked {
    border-color: rgba(201, 169, 110, 0.25);
    background: rgba(201, 169, 110, 0.06);
}

.achievement-card.locked {
    opacity: 0.45;
}

.achievement-card .ach-icon {
    font-size: 1.3rem;
    margin-bottom: 4px;
}

.achievement-card .ach-name {
    font-size: 0.75rem;
    font-weight: 400;
    color: #e8dcc8;
    margin-bottom: 2px;
}

.achievement-card .ach-desc {
    font-size: 0.6rem;
    color: rgba(232, 220, 200, 0.5);
    line-height: 1.3;
}

.achievement-card .ach-date {
    font-size: 0.55rem;
    color: rgba(201, 169, 110, 0.6);
    margin-top: 4px;
}

.achievements-close {
    background: transparent;
    border: 1px solid rgba(232, 220, 200, 0.2);
    border-radius: 20px;
    color: var(--text-secondary, rgba(232,220,200,0.6));
    padding: 8px 24px;
    font-size: 0.75rem;
    letter-spacing: 0.15em;
    text-transform: uppercase;
    cursor: pointer;
    transition: all 0.3s ease;
    margin-top: 20px;
}

.achievements-close:hover {
    border-color: rgba(232, 220, 200, 0.4);
    color: #e8dcc8;
}

/* Achievement toast notification */
.achievement-toast {
    position: fixed;
    top: 80px;
    left: 50%;
    transform: translateX(-50%) translateY(-20px);
    background: rgba(20, 30, 50, 0.95);
    border: 1px solid rgba(201, 169, 110, 0.4);
    border-radius: 12px;
    padding: 12px 24px;
    z-index: 100;
    text-align: center;
    opacity: 0;
    transition: opacity 0.5s ease, transform 0.5s ease;
    pointer-events: none;
    backdrop-filter: blur(10px);
}

.achievement-toast.show {
    opacity: 1;
    transform: translateX(-50%) translateY(0);
}

.achievement-toast .toast-icon {
    font-size: 1.5rem;
}

.achievement-toast .toast-label {
    font-size: 0.55rem;
    text-transform: uppercase;
    letter-spacing: 0.15em;
    color: #c9a96e;
    display: block;
    margin-top: 2px;
}

.achievement-toast .toast-name {
    font-size: 0.85rem;
    color: #e8dcc8;
    font-weight: 300;
}

.about-overlay {
    position: fixed; inset: 0;
    background: rgba(0,0,0,0.8);
    display: flex; align-items: center; justify-content: center;
    z-index: 1100;
    backdrop-filter: blur(6px);
    opacity: 0;
    transition: opacity 0.4s ease;
    pointer-events: none;
}

.about-overlay.visible {
    opacity: 1;
    pointer-events: auto;
}

.about-content {
    background: linear-gradient(180deg, #1a2a3a 0%, #0d1b2a 100%);
    border: 1px solid rgba(232, 220, 200, 0.15);
    border-radius: 16px;
    padding: 40px;
    max-width: 560px;
    width: 90%;
    max-height: 80vh;
    overflow-y: auto;
    color: #e8dcc8;
}

.about-content h2 {
    font-weight: 300;
    letter-spacing: 0.2em;
    text-transform: uppercase;
    text-align: center;
    margin-bottom: 24px;
    font-size: 1.3rem;
}

.about-content h3 {
    font-weight: 400;
    font-size: 0.85rem;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    color: #c9a96e;
    margin-top: 20px;
    margin-bottom: 8px;
}

.about-content p {
    font-size: 0.85rem;
    line-height: 1.7;
    font-weight: 300;
    color: rgba(232, 220, 200, 0.8);
    margin-bottom: 12px;
}

.about-close {
    display: block;
    margin: 24px auto 0;
    padding: 10px 32px;
    background: transparent;
    border: 1px solid rgba(232, 220, 200, 0.2);
    border-radius: 20px;
    color: #e8dcc8;
    cursor: pointer;
    font-size: 0.85rem;
    letter-spacing: 0.1em;
    transition: all 0.2s ease;
}

.about-close:hover {
    background: rgba(255,255,255,0.05);
    border-color: rgba(232, 220, 200, 0.4);
}

.about-byline {
    text-align: center;
    font-style: italic;
    color: rgba(232, 220, 200, 0.5) !important;
    margin-top: 20px !important;
    font-size: 0.8rem !important;
    letter-spacing: 0.05em;
}

/* Tap the glass ripple */
.tap-ripple {
    position: absolute;
    border-radius: 50%;
    border: 2px solid rgba(255,255,255,0.3);
    pointer-events: none;
    z-index: 12;
    animation: tapRippleExpand 0.6s ease-out forwards;
}

@keyframes tapRippleExpand {
    0% { transform: scale(0); opacity: 0.8; }
    100% { transform: scale(1); opacity: 0; }
}

/* ============================================
   GAME SCREEN & TANK
   ============================================ */

.game-screen {
    position: fixed; inset: 0;
    display: flex; flex-direction: column;
}

.hidden { display: none !important; }

.tank {
    flex: 1;
    position: relative;
    overflow: hidden;
    background: linear-gradient(180deg, var(--water-top) 0%, var(--water-mid) 50%, var(--water-bottom) 100%);
    transition: background 1.5s ease;
}

/* Sand bottom */
.tank::after {
    content: '';
    position: absolute;
    bottom: 0; left: 0; right: 0;
    height: 60px;
    background: linear-gradient(180deg, transparent 0%, var(--sand) 40%, var(--sand-light) 100%);
    z-index: 2;
    pointer-events: none;
}

/* Water surface */
.surface-ripples {
    position: absolute;
    top: 0; left: 0; right: 0;
    height: 6px;
    background: var(--surface-color);
    z-index: 10;
    overflow: hidden;
}

.surface-ripples::before {
    content: '';
    position: absolute;
    inset: 0;
    background: linear-gradient(90deg,
        transparent 0%,
        rgba(255,255,255,0.1) 20%,
        transparent 40%,
        rgba(255,255,255,0.08) 60%,
        transparent 80%
    );
    animation: surfaceRipple 8s ease-in-out infinite;
}

@keyframes surfaceRipple {
    0%, 100% { transform: translateX(-20%); }
    50% { transform: translateX(20%); }
}

/* Vignette */
.vignette {
    position: absolute; inset: 0;
    background: radial-gradient(ellipse at center, transparent 50%, rgba(0,0,0,0.4) 100%);
    pointer-events: none;
    z-index: 15;
}

/* Tank cloudiness overlay */
.tank-cloudiness {
    position: absolute;
    inset: 0;
    background: radial-gradient(ellipse at 50% 60%,
        rgba(120, 115, 80, 0.6) 0%,
        rgba(90, 95, 70, 0.4) 40%,
        rgba(70, 80, 60, 0.3) 100%);
    pointer-events: none;
    z-index: 12;
    opacity: 0;
    transition: opacity 2s ease;
}

/* Glass reflection */
.glass-reflection {
    position: absolute; inset: 0;
    background: linear-gradient(135deg,
        rgba(255,255,255,0.03) 0%,
        transparent 30%,
        transparent 70%,
        rgba(255,255,255,0.02) 100%
    );
    pointer-events: none;
    z-index: 16;
}

/* SVG Layers */
.water-effects, .plants-layer, .fish-layer, .food-layer, .bubbles-layer {
    position: absolute; inset: 0;
    width: 100%; height: 100%;
    pointer-events: none;
}

.water-effects { z-index: 1; }
.plants-layer { z-index: 3; }
.fish-layer { z-index: 5; }
.food-layer { z-index: 6; }
.bubbles-layer { z-index: 8; }
.particles-layer {
    position: absolute; inset: 0;
    pointer-events: none;
    z-index: 0;
}

/* Caustic light animation */
.caustic-cell {
    opacity: 0.06;
    animation: causticShimmer 6s ease-in-out infinite alternate;
}

@keyframes causticShimmer {
    0% { opacity: 0.04; }
    50% { opacity: 0.12; }
    100% { opacity: 0.06; }
}

/* ============================================
   HUD
   ============================================ */

.hud {
    position: absolute;
    top: 12px; left: 12px; right: 12px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    z-index: 20;
    pointer-events: none;
}

.hud-left, .hud-center, .hud-right {
    display: flex; align-items: center; gap: 16px;
    transition: opacity 0.3s ease;
}

.hud-left {
    min-width: 280px;
}

.hud-item {
    background: var(--hud-bg);
    border: 1px solid var(--hud-border);
    border-radius: 8px;
    padding: 8px 16px;
    backdrop-filter: blur(10px);
    pointer-events: auto;
}

.hud-label {
    font-size: 0.65rem;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    color: var(--text-secondary);
    display: block;
}

.hud-value {
    font-size: 1.2rem;
    font-weight: 300;
    letter-spacing: 0.05em;
    font-variant-numeric: tabular-nums;
}

#score-value {
    display: inline-block;
    min-width: 5ch;
    text-align: right;
}

.health-bar {
    width: 120px; height: 6px;
    background: rgba(255,255,255,0.1);
    border-radius: 3px;
    margin-top: 4px;
    overflow: hidden;
}

.health-fill {
    height: 100%;
    width: 100%;
    background: linear-gradient(90deg, #4ade80, #22c55e);
    border-radius: 3px;
    transition: width 0.5s ease, background 0.5s ease;
}

.health-fill.warning { background: linear-gradient(90deg, #fbbf24, #f59e0b); }
.health-fill.danger { background: linear-gradient(90deg, #ef4444, #dc2626); }

/* Multiplier badge */
.multiplier-badge {
    font-size: 0.55rem;
    font-weight: 500;
    color: rgba(232, 220, 200, 0.4);
    letter-spacing: 0.05em;
    display: block;
    transition: color 0.5s ease, text-shadow 0.5s ease;
}

.multiplier-badge.active {
    color: #f59e0b;
}

.multiplier-badge.high {
    color: #fb923c;
    text-shadow: 0 0 8px rgba(251, 146, 60, 0.5);
}

.multiplier-badge.max {
    color: #ef4444;
    text-shadow: 0 0 12px rgba(239, 68, 68, 0.6);
    animation: multiplierPulse 2s ease-in-out infinite;
}

@keyframes multiplierPulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
}

/* Multiplier detail panel */
.multiplier-panel {
    position: absolute;
    top: 55px; left: 12px;
    background: var(--hud-bg);
    border: 1px solid var(--hud-border);
    border-radius: 8px;
    padding: 12px 16px;
    backdrop-filter: blur(10px);
    z-index: 21;
    min-width: 180px;
    pointer-events: auto;
}

.multiplier-detail-title {
    font-size: 0.7rem;
    font-weight: 400;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    color: var(--text-secondary);
    margin-bottom: 6px;
}

.multiplier-detail-value {
    font-size: 1.4rem;
    font-weight: 300;
    color: var(--text-primary);
    margin-bottom: 6px;
}

.multiplier-detail-desc {
    font-size: 0.6rem;
    color: var(--text-secondary);
    line-height: 1.5;
}

.multiplier-tier {
    display: flex;
    justify-content: space-between;
    font-size: 0.55rem;
    padding: 2px 0;
    color: var(--text-secondary);
}

.multiplier-tier.current {
    color: #f59e0b;
    font-weight: 500;
}

.status-line {
    background: var(--hud-bg);
    border: 1px solid var(--hud-border);
    border-radius: 8px;
    padding: 8px 20px;
    font-size: 0.75rem;
    font-weight: 300;
    letter-spacing: 0.05em;
    color: var(--text-secondary);
    backdrop-filter: blur(10px);
    min-width: 250px;
    text-align: center;
    transition: opacity 0.3s ease;
}

/* Fish count detail */
.fish-detail-panel {
    position: absolute;
    top: 55px; right: 12px;
    background: var(--hud-bg);
    border: 1px solid var(--hud-border);
    border-radius: 8px;
    padding: 12px 16px;
    backdrop-filter: blur(10px);
    z-index: 21;
    min-width: 150px;
}

.fish-detail-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 3px 0;
    font-size: 0.75rem;
}

.fish-detail-row .fish-type-color {
    width: 10px; height: 10px;
    border-radius: 50%;
    display: inline-block;
    margin-right: 8px;
}

/* ============================================
   CONTROLS
   ============================================ */

/* Controls Wrapper */
.controls-wrapper {
    position: absolute;
    bottom: 12px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    flex-direction: column;
    align-items: center;
    z-index: 20;
    transition: transform 0.3s ease, opacity 0.3s ease;
}

.controls-wrapper.collapsed {
    transform: translateX(-50%) translateY(calc(100% - 22px));
}

.controls {
    display: flex;
    align-items: center;
    gap: 4px;
    background: var(--hud-bg);
    border: 1px solid var(--hud-border);
    border-radius: 12px;
    padding: 6px 10px;
    backdrop-filter: blur(10px);
    transition: opacity 0.3s ease;
    flex-wrap: nowrap;
}

.controls-wrapper.collapsed .controls {
    opacity: 0;
    pointer-events: none;
}

.ctrl-btn {
    display: flex; flex-direction: column;
    align-items: center; gap: 1px;
    background: transparent;
    border: 1px solid transparent;
    border-radius: 8px;
    padding: 6px 10px;
    color: var(--text-primary);
    cursor: pointer;
    transition: all 0.2s ease;
}

.ctrl-btn:hover {
    background: var(--btn-hover);
    border-color: var(--hud-border);
}

.ctrl-btn:active { transform: scale(0.95); }

.ctrl-btn:disabled {
    opacity: 0.3;
    cursor: not-allowed;
}

.ctrl-icon { font-size: 1.3rem; line-height: 1; }
.ctrl-icon svg { vertical-align: middle; }
.ctrl-label { font-size: 0.6rem; letter-spacing: 0.1em; text-transform: uppercase; }
.ctrl-cost {
    font-size: 0.5rem;
    color: #f59e0b;
    line-height: 1;
}

.ctrl-separator {
    width: 1px; height: 28px;
    background: var(--hud-border);
    margin: 0 2px;
}

.volume-flyout {
    position: absolute;
    bottom: 100%;
    right: 0;
    background: var(--hud-bg);
    border: 1px solid var(--hud-border);
    border-radius: 10px;
    padding: 16px 10px;
    margin-bottom: 8px;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.2s ease, transform 0.2s ease;
    transform: translateY(6px);
    backdrop-filter: blur(12px);
    z-index: 30;
}

.volume-flyout.open {
    opacity: 1;
    pointer-events: auto;
    transform: translateY(0);
}

.volume-slider-vertical {
    -webkit-appearance: none;
    appearance: none;
    width: 100px; height: 4px;
    background: rgba(255,255,255,0.15);
    border-radius: 2px;
    outline: none;
}

.volume-slider-vertical::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 16px; height: 16px;
    border-radius: 50%;
    background: var(--text-primary);
    cursor: pointer;
}

.volume-slider-vertical::-moz-range-thumb {
    width: 16px; height: 16px;
    border-radius: 50%;
    background: var(--text-primary);
    border: none;
    cursor: pointer;
}

.volume-slider-vertical::-moz-range-track {
    height: 4px;
    background: rgba(255,255,255,0.15);
    border-radius: 2px;
}

.theme-ink .volume-flyout {
    background: rgba(245, 240, 232, 0.95);
    border-color: rgba(42, 42, 42, 0.2);
}

.theme-ink .volume-slider-vertical {
    background: rgba(42, 42, 42, 0.25);
}

.theme-ink .volume-slider-vertical::-webkit-slider-thumb {
    background: #2a2a2a;
}

.theme-ink .volume-slider-vertical::-moz-range-thumb {
    background: #2a2a2a;
}

.theme-ink .volume-slider-vertical::-moz-range-track {
    background: rgba(42, 42, 42, 0.25);
}

.auto-control {
    display: flex; align-items: center; gap: 4px;
    padding: 0 4px;
    cursor: pointer;
}

.auto-control input[type="checkbox"] {
    -webkit-appearance: none;
    appearance: none;
    width: 32px; height: 16px;
    background: rgba(255,255,255,0.15);
    border-radius: 8px;
    position: relative;
    cursor: pointer;
    transition: background 0.3s ease;
    outline: none;
}

.auto-control input[type="checkbox"]::after {
    content: '';
    position: absolute;
    top: 2px; left: 2px;
    width: 12px; height: 12px;
    border-radius: 50%;
    background: var(--text-primary);
    transition: transform 0.3s ease;
}

.auto-control input[type="checkbox"]:checked {
    background: var(--accent);
}

.auto-control input[type="checkbox"]:checked::after {
    transform: translateX(16px);
}

.auto-label {
    font-size: 0.6rem;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    color: var(--text-primary);
}

.theme-ink .auto-control input[type="checkbox"] {
    background: rgba(42, 42, 42, 0.2);
}

/* ============================================
   MODAL
   ============================================ */

.modal {
    position: fixed; inset: 0;
    background: rgba(0,0,0,0.7);
    display: flex; align-items: center; justify-content: center;
    z-index: 100;
    backdrop-filter: blur(4px);
}

.modal-content {
    background: linear-gradient(180deg, #1a2a3a 0%, #0d1b2a 100%);
    border: 1px solid var(--hud-border);
    border-radius: 16px;
    padding: 32px;
    min-width: 500px;
    max-width: 600px;
}

.modal-content h2 {
    font-weight: 300;
    letter-spacing: 0.15em;
    text-transform: uppercase;
    margin-bottom: 24px;
    text-align: center;
}

.fish-shop {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 12px;
    margin-bottom: 24px;
}

.shop-item {
    display: flex; align-items: center; gap: 12px;
    padding: 12px 16px;
    background: rgba(255,255,255,0.05);
    border: 1px solid var(--hud-border);
    border-radius: 10px;
    cursor: pointer;
    transition: all 0.2s ease;
}

.shop-item:hover {
    background: rgba(255,255,255,0.1);
    border-color: var(--accent);
}

.shop-item:disabled, .shop-item.disabled {
    opacity: 0.4;
    cursor: not-allowed;
}

.shop-fish-preview {
    width: 48px; height: 32px;
}

.shop-fish-info {
    flex: 1;
}

.shop-fish-name {
    font-size: 0.85rem;
    font-weight: 400;
}

.shop-fish-cost {
    font-size: 0.7rem;
    color: #f59e0b;
}
.shop-fish-personality {
    font-size: 0.65rem;
    font-style: italic;
    color: rgba(255,255,255,0.5);
    margin-top: 1px;
}

.modal-close {
    display: block;
    margin: 0 auto;
    padding: 10px 32px;
    background: transparent;
    border: 1px solid var(--hud-border);
    border-radius: 20px;
    color: var(--text-primary);
    cursor: pointer;
    font-size: 0.85rem;
    letter-spacing: 0.1em;
    transition: all 0.2s ease;
}

.modal-close:hover {
    background: var(--btn-hover);
}

/* Fish Shop Flyout */
.fish-shop-flyout {
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%) translateY(10px);
    background: linear-gradient(180deg, rgba(20,34,56,0.97), rgba(10,22,40,0.98));
    border: 1px solid var(--hud-border);
    border-radius: 14px;
    padding: 16px;
    margin-bottom: 8px;
    width: max-content;
    max-width: min(420px, calc(100vw - 24px));
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.25s ease, transform 0.25s ease;
    backdrop-filter: blur(12px);
    z-index: 30;
}

.fish-shop-flyout.open {
    opacity: 1;
    pointer-events: auto;
    transform: translateX(-50%) translateY(0);
}

.fish-shop-flyout .fish-shop {
    display: flex;
    flex-direction: column;
    gap: 6px;
    margin-bottom: 0;
    max-height: 50vh;
    overflow-y: auto;
}

.fish-shop-flyout .shop-item {
    padding: 8px 12px;
    gap: 10px;
}

.fish-shop-flyout .shop-fish-preview {
    width: 40px;
    height: 28px;
}

.fish-shop-flyout .shop-fish-name {
    font-size: 0.75rem;
}

.fish-shop-flyout .shop-fish-cost {
    font-size: 0.65rem;
}

.fish-shop-flyout .shop-fish-personality {
    font-size: 0.55rem;
}

/* Flyout backdrop for tap-outside-to-dismiss */
.flyout-backdrop {
    position: fixed;
    inset: 0;
    z-index: 19;
    display: none;
}

.flyout-backdrop.active {
    display: block;
}

/* Restart Confirmation Modal */
.restart-modal-content {
    background: linear-gradient(180deg, #1a2a3a 0%, #0d1b2a 100%);
    border: 1px solid var(--hud-border);
    border-radius: 16px;
    padding: 32px 40px;
    text-align: center;
    min-width: 320px;
    max-width: 400px;
}

.restart-modal-content h3 {
    font-weight: 300;
    letter-spacing: 0.12em;
    text-transform: uppercase;
    margin: 0 0 12px 0;
    font-size: 1.1rem;
}

.restart-modal-content p {
    margin: 0 0 24px 0;
    opacity: 0.7;
    font-size: 0.85rem;
    line-height: 1.5;
}

.restart-modal-btns {
    display: flex;
    gap: 12px;
    justify-content: center;
}

.restart-modal-btns button {
    padding: 10px 28px;
    border-radius: 20px;
    font-size: 0.85rem;
    letter-spacing: 0.1em;
    cursor: pointer;
    transition: all 0.2s ease;
    font-family: inherit;
}

.restart-btn-confirm {
    background: rgba(239, 68, 68, 0.2);
    border: 1px solid rgba(239, 68, 68, 0.5);
    color: #fca5a5;
}

.restart-btn-confirm:hover {
    background: rgba(239, 68, 68, 0.35);
}

.restart-btn-cancel {
    background: transparent;
    border: 1px solid var(--hud-border);
    color: var(--text-primary);
}

.restart-btn-cancel:hover {
    background: var(--btn-hover);
}

/* Milestone modal */
.milestone-modal-content {
    background: linear-gradient(180deg, #1a2a3a 0%, #0d1b2a 100%);
    border: 1px solid rgba(201, 169, 110, 0.4);
    border-radius: 16px;
    padding: 32px 40px;
    text-align: center;
    min-width: 320px;
    max-width: 400px;
}

.milestone-icon {
    font-size: 3rem;
    margin-bottom: 8px;
}

.milestone-modal-content h3 {
    font-weight: 300;
    letter-spacing: 0.12em;
    text-transform: uppercase;
    margin: 0 0 8px 0;
    font-size: 1.2rem;
    color: #c9a96e;
}

.milestone-modal-content p {
    margin: 0 0 24px 0;
    opacity: 0.8;
    font-size: 0.85rem;
    line-height: 1.5;
}

.milestone-btn-continue {
    background: transparent;
    border: 1px solid var(--hud-border);
    color: var(--text-primary);
    padding: 10px 28px;
    border-radius: 20px;
    font-size: 0.85rem;
    letter-spacing: 0.1em;
    cursor: pointer;
    transition: all 0.2s ease;
    font-family: inherit;
}

.milestone-btn-continue:hover {
    background: var(--btn-hover);
}

.milestone-btn-end {
    background: rgba(201, 169, 110, 0.2);
    border: 1px solid rgba(201, 169, 110, 0.5);
    color: #c9a96e;
    padding: 10px 28px;
    border-radius: 20px;
    font-size: 0.85rem;
    letter-spacing: 0.1em;
    cursor: pointer;
    transition: all 0.2s ease;
    font-family: inherit;
}

.milestone-btn-end:hover {
    background: rgba(201, 169, 110, 0.35);
}

/* Victory cause (gold, vs red defeat-cause) */
.victory-cause {
    font-size: 0.85rem;
    color: #c9a96e;
    margin-bottom: 12px;
    font-weight: 300;
    letter-spacing: 0.05em;
}

/* Best milestone badge on stats ribbon and summary */
.best-milestone {
    font-size: 0.6rem;
    color: #c9a96e;
    letter-spacing: 0.05em;
}

/* Controls Chevron Toggle */
.controls-chevron {
    width: 48px;
    height: 20px;
    background: var(--hud-bg);
    border: 1px solid var(--hud-border);
    border-bottom: none;
    border-radius: 10px 10px 0 0;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    backdrop-filter: blur(10px);
    color: var(--text-primary);
    font-size: 0.75rem;
    opacity: 0.7;
    margin-bottom: -1px;
}

.controls-chevron:hover {
    opacity: 1;
}

.controls-chevron .chevron-icon {
    transition: transform 0.3s ease;
    display: inline-block;
    transform: rotate(-90deg);
    font-weight: bold;
}

.controls-wrapper.collapsed .chevron-icon {
    transform: rotate(90deg);
}

.theme-ink .restart-modal-content {
    background: linear-gradient(180deg, #f5f0e8 0%, #ede6d8 100%);
    border-color: #baa88a;
    color: #2a2a2a;
}

.theme-ink .restart-btn-confirm {
    background: rgba(180, 60, 40, 0.15);
    border-color: rgba(180, 60, 40, 0.5);
    color: #8a3a2a;
}

.theme-ink .restart-btn-cancel {
    color: #2a2a2a;
    border-color: #baa88a;
}

/* ============================================
   FISH SVG ANIMATIONS
   ============================================ */

.fish-group {
    transition: transform 0.05s linear;
}

.fish-body-path {
    transition: fill 0.5s ease;
}

.fish-fin {
    transform-origin: center;
}

.fish-tail {
}

.fish-dorsal-fin {
}

/* Easter egg creatures */
.creature-group {
    transition: transform 0.1s linear;
}

.creature-group .tentacle {
    animation: tentacleWave 2s ease-in-out infinite alternate;
}

.creature-group .tentacle:nth-child(odd) {
    animation-delay: -0.5s;
}

@keyframes tentacleWave {
    0% { transform: rotate(-3deg) translateX(-1px); }
    100% { transform: rotate(3deg) translateX(1px); }
}

/* Jellyfish stingers */
.stinger-group {
    pointer-events: none;
}

/* Ink cloud from octopus/squid */
.ink-cloud {
    pointer-events: none;
    transition: opacity 0.3s ease;
}

.fish-pectoral-fin {
}

/* Bubble animations */
.bubble {
    animation: bubbleRise linear forwards;
}

@keyframes bubbleRise {
    0% { transform: translateY(0) scale(0.7); opacity: 0.6; }
    50% { opacity: 0.4; }
    100% { transform: translateY(-100vh) scale(1.2); opacity: 0; }
}

/* Food - animated via JS */
.food-flake {
}

/* Plant sway */
.plant-group {
    transform-origin: bottom center;
}

/* Particle float */
.particle {
    position: absolute;
    border-radius: 50%;
    background: rgba(255,255,255,0.08);
    animation: particleFloat linear infinite;
}

@keyframes particleFloat {
    0% { transform: translate(0, 0); opacity: 0; }
    10% { opacity: 0.5; }
    90% { opacity: 0.3; }
    100% { transform: translate(var(--dx), var(--dy)); opacity: 0; }
}

/* ============================================
   THEME OVERRIDES
   ============================================ */

/* Koi Garden */
.theme-koi {
    --water-top: #1a3a5c;
    --water-bottom: #0a1628;
    --water-mid: #12294a;
    --accent: #e8845c;
    --sand: #2a1f14;
    --sand-light: #3d2e1f;
    --plant-primary: #2d5a3a;
    --plant-secondary: #1a3d28;
}

/* Tropical Reef */
.theme-tropical {
    --water-top: #0a4a6e;
    --water-bottom: #061a2e;
    --water-mid: #083858;
    --accent: #00d4aa;
    --accent-glow: rgba(0, 212, 170, 0.3);
    --sand: #3a2a18;
    --sand-light: #4d3a24;
    --plant-primary: #e04060;
    --plant-secondary: #c03050;
}

/* Deep Ocean */
.theme-deep {
    --water-top: #060d18;
    --water-bottom: #020508;
    --water-mid: #040a14;
    --accent: #4dc9f6;
    --accent-glow: rgba(77, 201, 246, 0.3);
    --sand: #0a0f18;
    --sand-light: #121824;
    --plant-primary: #1a3040;
    --plant-secondary: #0d1a28;
    --caustic-color: rgba(77, 201, 246, 0.07);
}

/* Zen Garden */
.theme-zen {
    --water-top: #1a1a1a;
    --water-bottom: #0a0a0a;
    --water-mid: #141414;
    --accent: #d4742c;
    --accent-glow: rgba(212, 116, 44, 0.3);
    --text-primary: #d4cec4;
    --sand: #1a1810;
    --sand-light: #24221a;
    --plant-primary: #2a2a20;
    --plant-secondary: #1a1a14;
    --caustic-color: rgba(255, 255, 255, 0.06);
}

/* Pen and Ink */
.theme-ink {
    --water-top: #f5f0e8;
    --water-bottom: #e8e0d4;
    --water-mid: #ede5da;
    --accent: #2a2a2a;
    --accent-glow: rgba(42, 42, 42, 0.3);
    --text-primary: #1a1a1a;
    --text-secondary: rgba(42, 42, 42, 0.6);
    --hud-bg: rgba(245, 240, 232, 0.9);
    --hud-border: rgba(42, 42, 42, 0.15);
    --btn-bg: rgba(245, 240, 232, 0.9);
    --btn-hover: rgba(220, 215, 205, 0.9);
    --sand: #d4cec4;
    --sand-light: #ddd7cd;
    --plant-primary: #3a3a3a;
    --plant-secondary: #5a5a5a;
    --surface-color: rgba(0, 0, 0, 0.03);
    --caustic-color: rgba(0, 0, 0, 0.04);
}

.theme-ink .tank {
    background: linear-gradient(180deg, var(--water-top), var(--water-mid), var(--water-bottom));
}

.theme-ink .vignette {
    background: radial-gradient(ellipse at center, transparent 50%, rgba(200, 190, 175, 0.4) 100%);
}

.theme-ink .hud,
.theme-ink .controls {
    color: #2a2a2a;
}

.theme-ink .ctrl-btn {
    border-color: rgba(42, 42, 42, 0.3);
    color: #2a2a2a;
}

.theme-ink .ctrl-btn:hover {
    background: rgba(42, 42, 42, 0.1);
}

.theme-ink .tank {
    background: linear-gradient(180deg, #f5f0e8, #ede5da, #e8e0d4) !important;
}

.theme-ink .sand-bottom {
    background: linear-gradient(180deg, transparent, #d4cec4) !important;
}

.theme-ink .modal-content {
    background: linear-gradient(180deg, #f5f0e8, #e8e0d4);
    color: #1a1a1a;
}

.theme-ink .shop-item {
    background: rgba(0,0,0,0.04);
    border-color: rgba(42, 42, 42, 0.15);
}

.theme-ink .shop-item:hover {
    background: rgba(0,0,0,0.08);
}

.theme-ink .fish-shop-flyout {
    background: linear-gradient(180deg, rgba(245,240,232,0.97), rgba(232,224,212,0.98));
    border-color: rgba(42, 42, 42, 0.2);
}

.theme-ink .fish-shop-flyout .shop-fish-name {
    color: #2a2a2a;
}

.theme-ink .fish-shop-flyout .shop-fish-cost {
    color: #8a6e2f;
}

.theme-ink .status-line {
    color: #2a2a2a;
}

.theme-ink .multiplier-panel {
    background: rgba(245, 240, 232, 0.95);
    border-color: rgba(42, 42, 42, 0.2);
}

/* ============================================
   RESPONSIVE
   ============================================ */

@media (max-width: 768px) {
    .splash-title h1 { font-size: 2.5rem; }
    .splash-content { padding: 24px 20px; }
    .theme-cards { grid-template-columns: repeat(2, 1fr); }
    .modal-content { min-width: auto; margin: 16px; }
    .achievements-content { margin: 16px; padding: 24px; }

    .hud.hud-minimized {
        justify-content: center;
    }

    .hud.hud-minimized .hud-left,
    .hud.hud-minimized .hud-right {
        display: none;
    }

    .hud.hud-minimized .hud-center {
        flex: 1;
        text-align: center;
    }
}

@media (max-width: 480px) {
    /* Splash */
    .splash-title h1 { font-size: 1.8rem; letter-spacing: 0.12em; }
    .splash-subtitle { font-size: 0.8rem; margin-bottom: 24px; letter-spacing: 0.12em; }
    .splash-content { padding: 16px 12px; }
    .splash-seaweed { display: none; }
    .theme-selection h2 { font-size: 0.85rem; margin-bottom: 12px; }
    .theme-cards { grid-template-columns: 1fr 1fr; gap: 8px; }
    .theme-card { padding: 14px 10px; }
    .theme-card-name { font-size: 0.75rem; }
    .theme-card-desc { font-size: 0.55rem; }

    /* Stats ribbon */
    .stats-ribbon { gap: 12px; font-size: 0.6rem; }
    .stats-ribbon .stat-icon { font-size: 0.75rem; }

    /* Splash footer */
    .splash-footer { margin-top: 16px; gap: 8px; }
    .about-btn { padding: 6px 14px; font-size: 0.6rem; }
    .splash-mute-btn { font-size: 1rem; width: 36px; height: 36px; }

    /* HUD */
    .hud { top: 6px; left: 6px; right: 6px; flex-direction: row; gap: 4px; }
    .hud-left, .hud-center, .hud-right { gap: 4px; }
    .hud-left { min-width: auto; flex-shrink: 0; }
    .hud-center { flex: 1 1 0; min-width: 0; overflow: hidden; }
    .hud-right { flex-shrink: 0; }
    .hud-item { padding: 4px 8px; border-radius: 6px; }
    .hud-label { font-size: 0.5rem; }
    .hud-value { font-size: 0.9rem; }
    .health-bar { width: 60px; height: 4px; }
    #status-value { font-size: 0.55rem; max-width: 80px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .status-line { min-width: 0; padding: 6px 10px; font-size: 0.65rem; white-space: normal; line-height: 1.3; }

    /* Controls */
    .controls-wrapper { bottom: 6px; }
    .controls { padding: 5px 6px; gap: 1px; border-radius: 10px; flex-wrap: nowrap; }
    .ctrl-btn { padding: 5px 6px; min-width: 38px; min-height: 38px; }
    .ctrl-icon { font-size: 1rem; }
    .ctrl-label { font-size: 0.4rem; letter-spacing: 0.03em; }
    .ctrl-cost { font-size: 0.4rem; }
    .ctrl-separator { display: none; }
    .auto-control { padding: 0 3px; gap: 2px; }
    .auto-label { font-size: 0.4rem; }

    /* Modals */
    .modal-content { padding: 20px 16px; border-radius: 12px; }
    .modal-content h2 { font-size: 1rem; margin-bottom: 16px; }
    .fish-shop { grid-template-columns: 1fr; gap: 8px; }
    .shop-item { padding: 10px 12px; gap: 8px; }
    .shop-fish-name { font-size: 0.75rem; }

    /* Session summary */
    .session-summary-content { padding: 24px 16px; max-width: 320px; }
    .session-summary h2 { font-size: 1.4rem; }
    .session-summary .summary-stats { gap: 8px; }
    .session-summary .summary-stat { padding: 8px 10px; }
    .session-summary .summary-stat-value { font-size: 0.95rem; }
    .session-summary .summary-btn { padding: 10px 24px; }

    /* Achievements overlay */
    .achievements-content { margin: 12px; padding: 20px 16px; max-width: calc(100vw - 24px); }
    .achievements-content h2 { font-size: 1.1rem; }
    .achievements-grid { grid-template-columns: 1fr 1fr; gap: 8px; }
    .achievement-card { padding: 10px; }
    .achievement-card .ach-icon { font-size: 1.1rem; }
    .achievement-card .ach-name { font-size: 0.65rem; }
    .achievement-card .ach-desc { font-size: 0.5rem; }

    /* Achievement toast */
    .achievement-toast { top: 50px; padding: 8px 16px; }

    /* Controls chevron */
    .controls-chevron { width: 36px; height: 16px; }
}

@media (max-width: 360px) {
    .splash-title h1 { font-size: 1.5rem; letter-spacing: 0.1em; }
    .splash-subtitle { font-size: 0.7rem; }
    .theme-cards { grid-template-columns: 1fr; gap: 6px; }
    .theme-card { padding: 12px 10px; }
    .stats-ribbon { flex-direction: column; gap: 6px; }
    .achievements-grid { grid-template-columns: 1fr; }
    .hud-item { padding: 3px 6px; }
    .hud-label { font-size: 0.45rem; }
    .hud-value { font-size: 0.8rem; }
    .health-bar { width: 45px; }
    .hud-center { flex: 0 1 auto; min-width: 0; overflow: hidden; }
    #status-value { max-width: 60px; }
    .ctrl-btn { padding: 4px 5px; min-width: 34px; min-height: 34px; }
    .ctrl-icon { font-size: 0.9rem; }
    .ctrl-label { font-size: 0.35rem; }
    .auto-control input[type="checkbox"] { width: 24px; height: 12px; }
    .auto-control input[type="checkbox"]::after { width: 8px; height: 8px; }
    .auto-control input[type="checkbox"]:checked::after { transform: translateX(12px); }
}

/* Touch device improvements */
@media (hover: none) {
    .about-btn { min-height: 44px; display: inline-flex; align-items: center; }
    .shop-item { min-height: 48px; }
    .theme-card:hover { transform: none; box-shadow: none; }
    .theme-card:active { transform: scale(0.97); }
    .ctrl-btn:hover { background: transparent; border-color: transparent; }
    .ctrl-btn:active { background: var(--btn-hover); border-color: var(--hud-border); transform: scale(0.92); }
    .controls-wrapper { bottom: max(6px, env(safe-area-inset-bottom)); }
    .hud { top: max(6px, env(safe-area-inset-top)); }
}

    </style>
</head>
<body>
    <!-- Splash Screen -->
    <div id="splash-screen" class="splash-screen">
        <div class="splash-content">
            <div class="splash-title">
                <h1>Zenquarium</h1>
                <p class="splash-subtitle">A meditative aquarium experience</p>
            </div>
            <div class="splash-bubbles" id="splash-bubbles"></div>
            <div class="splash-seaweed splash-seaweed-left" id="splash-seaweed-left"></div>
            <div class="splash-seaweed splash-seaweed-right" id="splash-seaweed-right"></div>
            <div class="theme-selection">
                <h2>Pick a theme to start</h2>
                <div class="theme-cards" id="theme-cards"></div>
            </div>
            <div class="splash-footer">
                <button class="about-btn" id="about-btn">About</button>
                <button class="about-btn" id="achievements-btn">Achievements</button>
                <button class="splash-mute-btn" id="splash-mute-btn" title="Toggle Sound">üîä</button>
            </div>
            <div id="stats-ribbon" class="stats-ribbon">
                <div class="stat-item"><span class="stat-icon">üèÜ</span> Best: <span class="stat-value" id="ribbon-high-score">0</span> <span class="best-milestone" id="ribbon-best-milestone"></span></div>
                <div class="stat-item"><span class="stat-icon">üéÆ</span> Sessions: <span class="stat-value" id="ribbon-sessions">0</span></div>
                <div class="stat-item"><span class="stat-icon">‚≠ê</span> <span class="stat-value" id="ribbon-achievements">0</span>/<span id="ribbon-total-achievements">12</span></div>
            </div>
        </div>
    </div>

    <!-- About Overlay -->
    <div id="about-overlay" class="about-overlay">
        <div class="about-content">
            <h2>Zenquarium</h2>
            <p>A meditative aquarium that's also a game. Tend a living digital fishtank ‚Äî or sit back and let it tend itself.</p>
            
            <h3>How to Play</h3>
            <p>Pick a theme and build your aquarium. Feed your fish, keep the tank clean, and buy new species to create a thriving ecosystem. Healthy fish earn points; neglected fish get hungry ‚Äî and big fish eat smaller ones.</p>

            <h3>Score &amp; Multiplier</h3>
            <p>Everything you do affects your score. Keep all fish healthy to build a streak multiplier (up to √ó3). Proactive cleaning, diverse tanks, and baby fish earn bonus points. Starvation, neglect, and stressed fish cost you.</p>

            <h3>Creatures &amp; Risk</h3>
            <p>Mystery creatures may visit your tank ‚Äî and they're hungry. Jellyfish drift through and sting fish in their path. Octopus and squid actively hunt your fish. Tap a creature to chase it away, but don't tap three times or it will retaliate with stingers or ink. Protect your fish for a bonus, or risk provoking a dangerous reaction for an even bigger reward if everyone survives.</p>

            <h3>Achievements</h3>
            <p>Discover 20 achievements across exploration, caretaking, and daring play ‚Äî each with a one-time score bonus. Can you unlock Zen Master?</p>

            <h3>Zen Mode</h3>
            <p>Toggle Zen mode to let the aquarium manage itself. Perfect for when you just want to sit back and enjoy the view.</p>

            <h3>Themes</h3>
            <p>Five handcrafted environments with unique fish, plants, and ambient soundscapes: <strong>Koi Garden</strong>, <strong>Tropical Reef</strong>, <strong>Deep Ocean</strong>, <strong>Zen Garden</strong>, and <strong>Pen &amp; Ink</strong>.</p>

            <p class="about-byline">Created by Coffee Czar ‚òï</p>

            <button class="about-close" id="about-close">Close</button>
        </div>
    </div>

    <!-- Session Summary Overlay -->
    <div id="session-summary" class="session-summary">
        <div class="session-summary-content">
            <h2>Game Summary</h2>
            <div id="defeat-cause" class="defeat-cause" style="display:none"></div>
            <div id="victory-cause" class="victory-cause" style="display:none"></div>
            <div id="high-score-badge" class="high-score-badge" style="display:none">üèÜ New High Score! üèÜ</div>
            <div class="summary-stats">
                <div class="summary-stat">
                    <span class="summary-stat-label">Score</span>
                    <span class="summary-stat-value" id="summary-score">0</span>
                </div>
                <div class="summary-stat">
                    <span class="summary-stat-label">Best Score</span>
                    <span class="summary-stat-value" id="summary-best">0</span>
                    <span class="best-milestone" id="summary-best-milestone"></span>
                </div>
                <div class="summary-stat">
                    <span class="summary-stat-label">Duration</span>
                    <span class="summary-stat-value" id="summary-duration">0:00</span>
                </div>
                <div class="summary-stat">
                    <span class="summary-stat-label">Fish Born</span>
                    <span class="summary-stat-value" id="summary-born">0</span>
                </div>
                <div class="summary-stat">
                    <span class="summary-stat-label">Fish Lost</span>
                    <span class="summary-stat-value" id="summary-lost">0</span>
                </div>
                <div class="summary-stat">
                    <span class="summary-stat-label">Peak Fish</span>
                    <span class="summary-stat-value" id="summary-peak">0</span>
                </div>
            </div>
            <div id="summary-achievements" class="summary-achievements"></div>
            <button class="summary-btn" id="summary-continue">Continue</button>
        </div>
    </div>

    <!-- Achievements Overlay -->
    <div id="achievements-overlay" class="achievements-overlay">
        <div class="achievements-content">
            <h2 id="achievements-title">Achievements</h2>
            <div id="achievements-grid" class="achievements-grid"></div>
            <button class="achievements-close" id="achievements-close">Close</button>
        </div>
    </div>

    <!-- Achievement Toast -->
    <div id="achievement-toast" class="achievement-toast">
        <span class="toast-icon" id="toast-icon"></span>
        <span class="toast-label">Achievement Unlocked</span>
        <span class="toast-name" id="toast-name"></span>
    </div>

    <!-- Game Screen -->
    <div id="game-screen" class="game-screen hidden">
        <!-- Tank Container -->
        <div id="tank" class="tank">
            <!-- Water effects layer -->
            <svg id="water-effects" class="water-effects" preserveAspectRatio="none">
                <defs>
                    <filter id="caustics-filter">
                        <feTurbulence type="fractalNoise" baseFrequency="0.015" numOctaves="3" seed="1" result="noise"/>
                        <feDisplacementMap in="SourceGraphic" in2="noise" scale="8" xChannelSelector="R" yChannelSelector="G"/>
                    </filter>
                    <radialGradient id="bubble-gradient" cx="35%" cy="35%">
                        <stop offset="0%" stop-color="rgba(255,255,255,0.6)"/>
                        <stop offset="100%" stop-color="rgba(255,255,255,0.1)"/>
                    </radialGradient>
                    <linearGradient id="light-ray" x1="0" y1="0" x2="0" y2="1">
                        <stop offset="0%" stop-color="rgba(255,255,255,0.15)"/>
                        <stop offset="100%" stop-color="rgba(255,255,255,0)"/>
                    </linearGradient>
                </defs>
                <!-- Caustic light patterns -->
                <g id="caustics-layer"></g>
                <!-- Light rays from surface -->
                <g id="light-rays"></g>
            </svg>

            <!-- Background particles -->
            <div id="particles-layer" class="particles-layer"></div>

            <!-- Plants layer -->
            <svg id="plants-layer" class="plants-layer" preserveAspectRatio="none"></svg>

            <!-- Fish layer -->
            <svg id="fish-layer" class="fish-layer" preserveAspectRatio="none"></svg>

            <!-- Food layer -->
            <svg id="food-layer" class="food-layer" preserveAspectRatio="none"></svg>

            <!-- Bubbles layer -->
            <svg id="bubbles-layer" class="bubbles-layer" preserveAspectRatio="none"></svg>

            <!-- Surface ripples -->
            <div id="surface-ripples" class="surface-ripples"></div>

            <!-- Tank cloudiness overlay -->
            <div id="tank-cloudiness" class="tank-cloudiness"></div>

            <!-- Vignette overlay -->
            <div class="vignette"></div>

            <!-- Tank glass reflection -->
            <div class="glass-reflection"></div>
        </div>

        <!-- HUD -->
        <div id="hud" class="hud">
            <div class="hud-left">
                <div class="hud-item" id="score-display">
                    <span class="hud-label">Score</span>
                    <span class="hud-value" id="score-value">100</span>
                    <span class="multiplier-badge" id="multiplier-badge">√ó1</span>
                </div>
                <div class="hud-item" id="health-display">
                    <span class="hud-label">Tank Health</span>
                    <div class="health-bar">
                        <div class="health-fill" id="health-fill"></div>
                    </div>
                </div>
            </div>
            <div class="hud-center">
                <div class="status-line" id="status-line">Welcome to Zenquarium</div>
            </div>
            <div class="hud-right">
                <div class="hud-item" id="fish-count-display">
                    <span class="hud-label">Fish</span>
                    <span class="hud-value" id="fish-count-value">0/20</span>
                </div>
            </div>
        </div>

        <!-- Fish Count Detail Panel -->
        <div id="fish-detail-panel" class="fish-detail-panel hidden">
            <div id="fish-detail-list"></div>
        </div>

        <!-- Multiplier Detail Panel -->
        <div id="multiplier-panel" class="multiplier-panel hidden">
            <div id="multiplier-detail"></div>
        </div>

        <!-- Controls Wrapper (chevron + bar) -->
        <div id="controls-wrapper" class="controls-wrapper">
            <div id="controls-chevron" class="controls-chevron" title="Toggle Controls">
                <span class="chevron-icon">¬ª</span>
            </div>
            <div id="controls" class="controls">
            <button class="ctrl-btn" id="btn-feed" title="Feed Fish">
                <span class="ctrl-icon"></span>
                <span class="ctrl-label">Feed</span>
                <span class="ctrl-cost" id="feed-cost">-5</span>
            </button>
            <button class="ctrl-btn" id="btn-clean" title="Clean Tank">
                <span class="ctrl-icon"></span>
                <span class="ctrl-label">Clean</span>
                <span class="ctrl-cost" id="clean-cost">-10</span>
            </button>
            <button class="ctrl-btn" id="btn-buy" title="Buy Fish">
                <span class="ctrl-icon"></span>
                <span class="ctrl-label">Buy</span>
                <span class="ctrl-cost" id="buy-cost">-20</span>
            </button>
            <div class="ctrl-separator"></div>
            <button class="ctrl-btn" id="btn-pause" title="Pause">
                <span class="ctrl-icon"></span>
                <span class="ctrl-label">Pause</span>
            </button>
            <button class="ctrl-btn" id="btn-restart" title="Restart">
                <span class="ctrl-icon"><svg width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round"><path d="M4.5 3.2A5.5 5.5 0 1 1 2.5 8"/><path d="M5 1v3.5H1.5" stroke-width="1.5"/></svg></span>
                <span class="ctrl-label">Restart</span>
            </button>
            <div class="ctrl-separator"></div>
            <label class="auto-control" title="Zen Mode">
                <input type="checkbox" id="auto-toggle">
                <span class="auto-label">Zen</span>
            </label>
            <div class="ctrl-separator"></div>
            <button class="ctrl-btn" id="btn-volume" title="Volume">
                <span class="ctrl-icon" id="volume-icon-display">üîä</span>
                <span class="ctrl-label">Vol</span>
            </button>
        </div>
            <!-- Volume Flyout -->
            <div id="volume-flyout" class="volume-flyout">
                <input type="range" id="volume-slider" min="0" max="100" value="50" class="volume-slider volume-slider-vertical">
            </div>
            <!-- Fish Shop Flyout -->
            <div id="fish-shop-flyout" class="fish-shop-flyout">
                <div id="fish-shop" class="fish-shop"></div>
            </div>
        </div>

        <!-- Flyout backdrop -->
        <div id="flyout-backdrop" class="flyout-backdrop"></div>

        <!-- Restart Confirmation Modal -->
        <div id="restart-modal" class="modal hidden">
            <div class="restart-modal-content">
                <h3>Restart?</h3>
                <p>All progress will be lost. Your fish, score, and tank state will be reset.</p>
                <div class="restart-modal-btns">
                    <button class="restart-btn-confirm" id="restart-confirm">Restart</button>
                    <button class="restart-btn-cancel" id="restart-cancel">Cancel</button>
                </div>
            </div>
        </div>

        <div id="milestone-modal" class="modal hidden">
            <div class="milestone-modal-content">
                <div class="milestone-icon" id="milestone-icon">ü•â</div>
                <h3 id="milestone-title">Bronze Aquarist</h3>
                <p id="milestone-message">You've reached 1,000 points!</p>
                <div class="restart-modal-btns">
                    <button class="milestone-btn-continue" id="milestone-continue">Keep Playing</button>
                    <button class="milestone-btn-end" id="milestone-end">End on a High Note</button>
                </div>
            </div>
        </div>
    </div>

    <script>
/* ============================================
   ZENQUARIUM - Persistent Storage
   ============================================ */

const ZenStorage = (() => {
    const STORAGE_KEY = 'zenquarium_save';

    const defaults = {
        highScore: 0,
        totalSessions: 0,
        achievements: [],
        achievementDates: {},
        lastTheme: null,
        themesPlayed: [],
        bestMilestone: null,
        stats: {
            totalFishBorn: 0,
            totalFishLost: 0,
            longestSession: 0,
            creaturesEncountered: 0,
            totalFoodDropped: 0,
            totalCleans: 0,
            highestFishCount: 0
        }
    };

    let data = null;

    function load() {
        try {
            const raw = localStorage.getItem(STORAGE_KEY);
            if (raw) {
                const saved = JSON.parse(raw);
                // Merge with defaults so new fields are always present
                data = { ...defaults, ...saved, stats: { ...defaults.stats, ...(saved.stats || {}) } };
            } else {
                data = JSON.parse(JSON.stringify(defaults));
            }
        } catch (e) {
            data = JSON.parse(JSON.stringify(defaults));
        }
        return data;
    }

    function save() {
        try {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
        } catch (e) { /* storage full or unavailable */ }
    }

    function get() {
        if (!data) load();
        return data;
    }

    function updateHighScore(score) {
        const d = get();
        const rounded = Math.round(score);
        if (rounded > d.highScore) {
            d.highScore = rounded;
            save();
            return true; // new high score
        }
        return false;
    }

    function incrementSessions() {
        const d = get();
        d.totalSessions++;
        save();
    }

    function addStat(key, amount = 1) {
        const d = get();
        if (key in d.stats) {
            d.stats[key] += amount;
            save();
        }
    }

    function setStatMax(key, value) {
        const d = get();
        if (key in d.stats && value > d.stats[key]) {
            d.stats[key] = value;
            save();
        }
    }

    function unlockAchievement(id) {
        const d = get();
        if (!d.achievements.includes(id)) {
            d.achievements.push(id);
            d.achievementDates[id] = new Date().toISOString().split('T')[0];
            save();
            return true; // newly unlocked
        }
        return false;
    }

    function hasAchievement(id) {
        return get().achievements.includes(id);
    }

    function recordTheme(themeId) {
        const d = get();
        d.lastTheme = themeId;
        if (!d.themesPlayed.includes(themeId)) {
            d.themesPlayed.push(themeId);
        }
        save();
    }

    function reset() {
        data = JSON.parse(JSON.stringify(defaults));
        save();
    }

    return { load, save, get, updateHighScore, incrementSessions, addStat, setStatMax, unlockAchievement, hasAchievement, recordTheme, reset };
})();


/* ============================================
   ZENQUARIUM - Utility Functions
   ============================================ */

const Utils = {
    // Random number in range
    rand(min, max) {
        return Math.random() * (max - min) + min;
    },

    randInt(min, max) {
        return Math.floor(this.rand(min, max + 1));
    },

    // Clamp value
    clamp(val, min, max) {
        return Math.max(min, Math.min(max, val));
    },

    // Lerp
    lerp(a, b, t) {
        return a + (b - a) * t;
    },

    // Distance between two points
    dist(x1, y1, x2, y2) {
        return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
    },

    // Easing functions
    easeInOutCubic(t) {
        return t < 0.5 ? 4 * t * t * t : 1 - (-2 * t + 2) ** 3 / 2;
    },

    easeOutCubic(t) {
        return 1 - (1 - t) ** 3;
    },

    easeInOutQuad(t) {
        return t < 0.5 ? 2 * t * t : 1 - (-2 * t + 2) ** 2 / 2;
    },

    // Create SVG element with attributes
    svgEl(tag, attrs = {}) {
        const el = document.createElementNS('http://www.w3.org/2000/svg', tag);
        for (const [k, v] of Object.entries(attrs)) {
            el.setAttribute(k, v);
        }
        return el;
    },

    // Create HTML element
    htmlEl(tag, className, text) {
        const el = document.createElement(tag);
        if (className) el.className = className;
        if (text) el.textContent = text;
        return el;
    },

    // Pick random from array
    pick(arr) {
        return arr[Math.floor(Math.random() * arr.length)];
    },

    // Weighted random pick
    weightedPick(items, weights) {
        const total = weights.reduce((a, b) => a + b, 0);
        let r = Math.random() * total;
        for (let i = 0; i < items.length; i++) {
            r -= weights[i];
            if (r <= 0) return items[i];
        }
        return items[items.length - 1];
    },

    // Color helpers
    hexToRgb(hex) {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return { r, g, b };
    },

    rgbToHex(r, g, b) {
        return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
    },

    // Lighten/darken color
    adjustColor(hex, amount) {
        const { r, g, b } = this.hexToRgb(hex);
        return this.rgbToHex(
            this.clamp(r + amount, 0, 255),
            this.clamp(g + amount, 0, 255),
            this.clamp(b + amount, 0, 255)
        );
    },

    // Generate unique ID
    uid() {
        return '_' + Math.random().toString(36).slice(2, 9);
    },

    // Debounce
    debounce(fn, ms) {
        let timer;
        return (...args) => {
            clearTimeout(timer);
            timer = setTimeout(() => fn(...args), ms);
        };
    },

    // Format number with commas
    formatNum(n) {
        return Math.round(n).toLocaleString();
    },

    // Angle between two points (radians)
    angle(x1, y1, x2, y2) {
        return Math.atan2(y2 - y1, x2 - x1);
    },

    // Smooth step
    smoothstep(edge0, edge1, x) {
        const t = this.clamp((x - edge0) / (edge1 - edge0), 0, 1);
        return t * t * (3 - 2 * t);
    }
};


/* ============================================
   ZENQUARIUM - Audio System (Web Audio API)
   ============================================ */

const ZenAudio = (() => {
    let ctx = null;
    let masterGain = null;
    let ambientGain = null;
    let sfxGain = null;
    let volume = 0.5;
    let ambientNodes = [];
    let isPlaying = false;

    function init() {
        ctx = new (window.AudioContext || window.webkitAudioContext)();
        masterGain = ctx.createGain();
        masterGain.gain.value = volume;
        masterGain.connect(ctx.destination);

        ambientGain = ctx.createGain();
        ambientGain.gain.value = 0.8;
        ambientGain.connect(masterGain);

        sfxGain = ctx.createGain();
        sfxGain.gain.value = 0.6;
        sfxGain.connect(masterGain);
    }

    function ensureCtx() {
        if (!ctx) init();
        if (ctx.state === 'suspended') ctx.resume();
    }

    // Create filtered noise for water sounds
    function createNoise(duration) {
        const bufferSize = ctx.sampleRate * duration;
        const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
        }
        return buffer;
    }

    // Gentle water ambience
    function startWaterAmbient() {
        const noise = ctx.createBufferSource();
        noise.buffer = createNoise(4);
        noise.loop = true;

        const lpf = ctx.createBiquadFilter();
        lpf.type = 'lowpass';
        lpf.frequency.value = 200;
        lpf.Q.value = 1;

        const hpf = ctx.createBiquadFilter();
        hpf.type = 'highpass';
        hpf.frequency.value = 40;

        const gain = ctx.createGain();
        gain.gain.value = 0.22;

        // Subtle modulation
        const lfo = ctx.createOscillator();
        lfo.type = 'sine';
        lfo.frequency.value = 0.1;
        const lfoGain = ctx.createGain();
        lfoGain.gain.value = 30;
        lfo.connect(lfoGain);
        lfoGain.connect(lpf.frequency);
        lfo.start();

        noise.connect(hpf);
        hpf.connect(lpf);
        lpf.connect(gain);
        gain.connect(ambientGain);
        noise.start();

        ambientNodes.push(noise, lfo);
    }

    // Gentle tonal pad with theme-specific character
    function startTonalPad(baseFreq = 65, themeId = 'koi') {
        // Each theme gets a distinct musical flavor
        const themeChords = {
            // Koi: Japanese pentatonic (miyako-bushi) - warm, contemplative
            koi: [1, 1.125, 1.333, 1.5, 1.778],
            // Tropical: Major with added 6th - bright, island feel
            tropical: [1, 1.25, 1.5, 1.667, 2],
            // Deep: Minor with b5 - mysterious, dark
            deep: [1, 1.189, 1.414, 1.587, 1.888],
            // Zen: Open fifths/fourths - sparse, meditative
            zen: [1, 1.333, 1.5, 2, 2.667],
            // Ink: Whole-tone scale - impressionistic, floating
            ink: [1, 1.122, 1.26, 1.414, 1.587]
        };

        const intervals = themeChords[themeId] || themeChords.koi;

        // Create 3 layered oscillators from the chord
        const oscCount = 3;
        for (let i = 0; i < oscCount; i++) {
            const osc = ctx.createOscillator();
            osc.type = i === 0 ? 'sine' : 'triangle';
            osc.frequency.value = baseFreq * intervals[i];

            const gain = ctx.createGain();
            gain.gain.value = i === 0 ? 0.10 : (i === 1 ? 0.06 : 0.03);

            // Slow evolving vibrato
            const vibrato = ctx.createOscillator();
            vibrato.type = 'sine';
            vibrato.frequency.value = 0.05 + i * 0.03;
            const vibGain = ctx.createGain();
            vibGain.gain.value = 0.8 + i * 0.3;
            vibrato.connect(vibGain);
            vibGain.connect(osc.frequency);

            osc.connect(gain);
            gain.connect(ambientGain);
            osc.start();
            vibrato.start();

            ambientNodes.push(osc, vibrato);
        }
    }

    // Theme-specific melodic patterns that play periodically
    function playThemeMelody(themeId) {
        if (!ctx || !isPlaying) return;

        const melodies = {
            // Koi: Pentatonic koto-like plucks (C D E G A)
            koi: { notes: [262, 294, 330, 392, 440, 392, 330, 294], type: 'sine', decay: 1.5, vol: 0.07, interval: 0.4 },
            // Tropical: Steel drum / marimba arpeggios (C E G B C')
            tropical: { notes: [330, 392, 494, 523, 659, 523, 494, 392], type: 'triangle', decay: 0.8, vol: 0.06, interval: 0.25 },
            // Deep: Sub-oceanic resonance ‚Äî very low, long sustain
            deep: { notes: [65, 82, 98, 110, 131, 110, 82, 65], type: 'sine', decay: 3.5, vol: 0.14, interval: 0.9 },
            // Zen: Singing bowl tones - resonant, sparse
            zen: { notes: [392, 523, 659, 784], type: 'sine', decay: 3.0, vol: 0.06, interval: 1.2 },
            // Ink: Piano-like impressionist phrases (whole-tone scale)
            ink: { notes: [330, 370, 415, 466, 523, 466, 370, 330], type: 'sine', decay: 1.8, vol: 0.06, interval: 0.35 }
        };

        const m = melodies[themeId] || melodies.koi;
        const noteCount = Utils.randInt(3, Math.min(5, m.notes.length));
        const startIdx = Utils.randInt(0, m.notes.length - noteCount);

        for (let i = 0; i < noteCount; i++) {
            const freq = m.notes[startIdx + i];
            const t = ctx.currentTime + i * m.interval;

            const osc = ctx.createOscillator();
            osc.type = m.type;
            osc.frequency.value = freq;

            // Add subtle pitch drift for organic feel
            osc.frequency.setValueAtTime(freq, t);
            osc.frequency.linearRampToValueAtTime(freq * (1 + Utils.rand(-0.003, 0.003)), t + m.decay * 0.5);

            const gain = ctx.createGain();
            gain.gain.setValueAtTime(0, t);
            gain.gain.linearRampToValueAtTime(m.vol, t + 0.05);
            gain.gain.exponentialRampToValueAtTime(0.001, t + m.decay);

            // Soft filter for warmth
            const filter = ctx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = themeId === 'deep' ? 900 : (themeId === 'zen' ? 2000 : 1400);
            filter.Q.value = themeId === 'zen' ? 4 : 1;

            osc.connect(filter);
            filter.connect(gain);
            gain.connect(ambientGain);
            osc.start(t);
            osc.stop(t + m.decay);
        }
    }

    // Theme-specific ambient texture sounds
    function playThemeTexture(themeId) {
        if (!ctx || !isPlaying) return;

        if (themeId === 'koi') {
            // Wind chime / bamboo clack
            const notes = [1318, 1568, 2093, 2637];
            const note = Utils.pick(notes);
            const osc = ctx.createOscillator();
            osc.type = 'sine';
            osc.frequency.value = note;
            const gain = ctx.createGain();
            gain.gain.setValueAtTime(0, ctx.currentTime);
            gain.gain.linearRampToValueAtTime(0.04, ctx.currentTime + 0.05);
            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 2);
            osc.connect(gain);
            gain.connect(ambientGain);
            osc.start();
            osc.stop(ctx.currentTime + 2);
        } else if (themeId === 'tropical') {
            // Distant bird-like chirp
            const osc = ctx.createOscillator();
            osc.type = 'sine';
            const f0 = Utils.rand(1800, 3000);
            osc.frequency.setValueAtTime(f0, ctx.currentTime);
            osc.frequency.linearRampToValueAtTime(f0 * 1.3, ctx.currentTime + 0.06);
            osc.frequency.linearRampToValueAtTime(f0 * 0.9, ctx.currentTime + 0.12);
            const gain = ctx.createGain();
            gain.gain.setValueAtTime(0, ctx.currentTime);
            gain.gain.linearRampToValueAtTime(0.03, ctx.currentTime + 0.02);
            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.2);
            osc.connect(gain);
            gain.connect(ambientGain);
            osc.start();
            osc.stop(ctx.currentTime + 0.2);
        } else if (themeId === 'deep') {
            // Deep ocean: layered sub-bass drone + whale sweep + metallic resonance
            const t = ctx.currentTime;

            // Sub-bass drone ‚Äî very deep, long sustain
            const subOsc = ctx.createOscillator();
            subOsc.type = 'sine';
            const subFreq = Utils.pick([33, 41, 49, 55]);
            subOsc.frequency.setValueAtTime(subFreq, t);
            subOsc.frequency.linearRampToValueAtTime(subFreq * Utils.rand(0.95, 1.05), t + 4);
            const subGain = ctx.createGain();
            subGain.gain.setValueAtTime(0, t);
            subGain.gain.linearRampToValueAtTime(0.18, t + 0.8);
            subGain.gain.linearRampToValueAtTime(0.12, t + 3);
            subGain.gain.exponentialRampToValueAtTime(0.001, t + 5);
            subOsc.connect(subGain);
            subGain.connect(ambientGain);
            subOsc.start(t);
            subOsc.stop(t + 5);

            // Whale-like sweep with harmonic overtone
            const whaleF = Utils.rand(70, 140);
            [1, 2.02].forEach((partial, pi) => {
                const osc = ctx.createOscillator();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(whaleF * partial, t + 0.2);
                osc.frequency.exponentialRampToValueAtTime(whaleF * partial * Utils.rand(2, 3.5), t + 1.8);
                osc.frequency.exponentialRampToValueAtTime(whaleF * partial * 0.6, t + 4);
                const gain = ctx.createGain();
                const vol = pi === 0 ? 0.14 : 0.07;
                gain.gain.setValueAtTime(0, t + 0.2);
                gain.gain.linearRampToValueAtTime(vol, t + 0.6);
                gain.gain.exponentialRampToValueAtTime(0.001, t + 4);
                const lpf = ctx.createBiquadFilter();
                lpf.type = 'lowpass';
                lpf.frequency.value = pi === 0 ? 400 : 800;
                lpf.Q.value = 1.5;
                osc.connect(lpf);
                lpf.connect(gain);
                gain.connect(ambientGain);
                osc.start(t + 0.2);
                osc.stop(t + 4);
            });

            // Metallic deep resonance ping
            const pingF = Utils.pick([65, 82, 98]);
            const pingOsc = ctx.createOscillator();
            pingOsc.type = 'triangle';
            pingOsc.frequency.value = pingF;
            const pingGain = ctx.createGain();
            pingGain.gain.setValueAtTime(0, t + 0.8);
            pingGain.gain.linearRampToValueAtTime(0.08, t + 0.85);
            pingGain.gain.exponentialRampToValueAtTime(0.001, t + 4.5);
            const pingFilter = ctx.createBiquadFilter();
            pingFilter.type = 'bandpass';
            pingFilter.frequency.value = pingF * 3;
            pingFilter.Q.value = 6;
            pingOsc.connect(pingFilter);
            pingFilter.connect(pingGain);
            pingGain.connect(ambientGain);
            pingOsc.start(t + 0.8);
            pingOsc.stop(t + 4.5);
        } else if (themeId === 'zen') {
            // Singing bowl resonance
            const fundamentals = [262, 330, 392, 523];
            const f0 = Utils.pick(fundamentals);
            const partials = [1, 2.71, 5.4];
            partials.forEach((p, idx) => {
                const osc = ctx.createOscillator();
                osc.type = 'sine';
                osc.frequency.value = f0 * p;
                const gain = ctx.createGain();
                const vol = 0.06 / (idx + 1);
                gain.gain.setValueAtTime(0, ctx.currentTime);
                gain.gain.linearRampToValueAtTime(vol, ctx.currentTime + 0.1);
                gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 4);
                osc.connect(gain);
                gain.connect(ambientGain);
                osc.start();
                osc.stop(ctx.currentTime + 4);
            });
        } else if (themeId === 'ink') {
            // Soft piano-like tone with gentle hammer feel
            const notes = [262, 294, 330, 370, 415, 466, 523];
            const f0 = Utils.pick(notes);
            const osc = ctx.createOscillator();
            osc.type = 'triangle';
            osc.frequency.value = f0;
            const gain = ctx.createGain();
            gain.gain.setValueAtTime(0, ctx.currentTime);
            gain.gain.linearRampToValueAtTime(0.07, ctx.currentTime + 0.01);
            gain.gain.exponentialRampToValueAtTime(0.035, ctx.currentTime + 0.1);
            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 2.5);
            const filter = ctx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 1800;
            osc.connect(filter);
            filter.connect(gain);
            gain.connect(ambientGain);
            osc.start();
            osc.stop(ctx.currentTime + 2.5);
        }
    }

    // Occasional water drip
    function playDrip() {
        ensureCtx();
        const osc = ctx.createOscillator();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(1200, ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(300, ctx.currentTime + 0.15);

        const gain = ctx.createGain();
        gain.gain.setValueAtTime(0.08, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.3);

        const filter = ctx.createBiquadFilter();
        filter.type = 'bandpass';
        filter.frequency.value = 600;
        filter.Q.value = 2;

        osc.connect(filter);
        filter.connect(gain);
        gain.connect(sfxGain);
        osc.start();
        osc.stop(ctx.currentTime + 0.3);
    }

    // Feeding plop sound
    function playPlop() {
        ensureCtx();
        const osc = ctx.createOscillator();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(400, ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(80, ctx.currentTime + 0.1);

        const gain = ctx.createGain();
        gain.gain.setValueAtTime(0.15, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.2);

        osc.connect(gain);
        gain.connect(sfxGain);
        osc.start();
        osc.stop(ctx.currentTime + 0.2);
    }

    // Baby fish born - gentle chime
    function playBirth() {
        ensureCtx();
        const notes = [523, 659, 784, 1047]; // C5, E5, G5, C6
        notes.forEach((freq, i) => {
            const osc = ctx.createOscillator();
            osc.type = 'sine';
            const gain = ctx.createGain();
            const t = ctx.currentTime + i * 0.12;
            gain.gain.setValueAtTime(0, t);
            gain.gain.linearRampToValueAtTime(0.1, t + 0.05);
            gain.gain.exponentialRampToValueAtTime(0.001, t + 0.6);
            osc.frequency.value = freq;
            osc.connect(gain);
            gain.connect(sfxGain);
            osc.start(t);
            osc.stop(t + 0.6);
        });
    }

    // Fish eaten - low thud
    function playEaten() {
        ensureCtx();
        const osc = ctx.createOscillator();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(150, ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(40, ctx.currentTime + 0.15);

        const gain = ctx.createGain();
        gain.gain.setValueAtTime(0.12, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.25);

        osc.connect(gain);
        gain.connect(sfxGain);
        osc.start();
        osc.stop(ctx.currentTime + 0.25);
    }

    // Cleaning sparkle sound
    function playCleaning() {
        ensureCtx();
        for (let i = 0; i < 5; i++) {
            const osc = ctx.createOscillator();
            osc.type = 'sine';
            const t = ctx.currentTime + i * 0.08;
            osc.frequency.value = Utils.rand(2000, 5000);
            const gain = ctx.createGain();
            gain.gain.setValueAtTime(0, t);
            gain.gain.linearRampToValueAtTime(0.05, t + 0.02);
            gain.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
            osc.connect(gain);
            gain.connect(sfxGain);
            osc.start(t);
            osc.stop(t + 0.15);
        }
    }

    // Fish bubble sound - soft ascending pop
    function playBubble() {
        ensureCtx();
        const osc = ctx.createOscillator();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(600 + Math.random() * 400, ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(1200 + Math.random() * 600, ctx.currentTime + 0.08);

        const gain = ctx.createGain();
        gain.gain.setValueAtTime(0.04, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.12);

        const filter = ctx.createBiquadFilter();
        filter.type = 'highpass';
        filter.frequency.value = 800;

        osc.connect(filter);
        filter.connect(gain);
        gain.connect(sfxGain);
        osc.start();
        osc.stop(ctx.currentTime + 0.12);
    }

    // Glass tap sound ‚Äî resonant thud with glass ring
    function playTapGlass(intensity = 1) {
        ensureCtx();
        const t = ctx.currentTime;

        // Low thud (knuckle on glass)
        const thud = ctx.createOscillator();
        thud.type = 'sine';
        thud.frequency.setValueAtTime(180, t);
        thud.frequency.exponentialRampToValueAtTime(60, t + 0.15);
        const thudGain = ctx.createGain();
        thudGain.gain.setValueAtTime(0.15 * intensity, t);
        thudGain.gain.exponentialRampToValueAtTime(0.001, t + 0.2);
        thud.connect(thudGain);
        thudGain.connect(sfxGain);
        thud.start(t);
        thud.stop(t + 0.2);

        // Glass ring (high resonant harmonics)
        const ringFreqs = [2200, 3400, 4800];
        ringFreqs.forEach((f, i) => {
            const osc = ctx.createOscillator();
            osc.type = 'sine';
            osc.frequency.value = f + Utils.rand(-50, 50);
            const gain = ctx.createGain();
            const vol = (0.04 - i * 0.01) * intensity;
            gain.gain.setValueAtTime(0, t);
            gain.gain.linearRampToValueAtTime(vol, t + 0.005);
            gain.gain.exponentialRampToValueAtTime(0.001, t + 0.6 + i * 0.2);
            const filter = ctx.createBiquadFilter();
            filter.type = 'bandpass';
            filter.frequency.value = f;
            filter.Q.value = 15;
            osc.connect(filter);
            filter.connect(gain);
            gain.connect(sfxGain);
            osc.start(t);
            osc.stop(t + 0.8 + i * 0.2);
        });

        // Noise burst (impact texture)
        const noiseLen = 0.05;
        const buf = ctx.createBuffer(1, ctx.sampleRate * noiseLen, ctx.sampleRate);
        const data = buf.getChannelData(0);
        for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1) * 0.5;
        const noiseSrc = ctx.createBufferSource();
        noiseSrc.buffer = buf;
        const noiseGain = ctx.createGain();
        noiseGain.gain.setValueAtTime(0.08 * intensity, t);
        noiseGain.gain.exponentialRampToValueAtTime(0.001, t + 0.06);
        const hpf = ctx.createBiquadFilter();
        hpf.type = 'highpass';
        hpf.frequency.value = 1000;
        noiseSrc.connect(hpf);
        hpf.connect(noiseGain);
        noiseGain.connect(sfxGain);
        noiseSrc.start(t);
        noiseSrc.stop(t + noiseLen);
    }

    // Jellyfish stinger release ‚Äî eerie descending tones
    function playStingerRelease() {
        ensureCtx();
        const t = ctx.currentTime;
        for (let i = 0; i < 4; i++) {
            const osc = ctx.createOscillator();
            osc.type = 'sine';
            const freq = Utils.rand(800, 1400);
            osc.frequency.setValueAtTime(freq, t + i * 0.06);
            osc.frequency.exponentialRampToValueAtTime(freq * 0.3, t + i * 0.06 + 0.5);
            const gain = ctx.createGain();
            gain.gain.setValueAtTime(0.06, t + i * 0.06);
            gain.gain.exponentialRampToValueAtTime(0.001, t + i * 0.06 + 0.5);
            const filter = ctx.createBiquadFilter();
            filter.type = 'bandpass';
            filter.frequency.value = freq * 0.8;
            filter.Q.value = 5;
            osc.connect(filter);
            filter.connect(gain);
            gain.connect(sfxGain);
            osc.start(t + i * 0.06);
            osc.stop(t + i * 0.06 + 0.6);
        }
    }

    // Ink squirt ‚Äî low whoosh with bubbling texture
    function playInkSquirt() {
        ensureCtx();
        const t = ctx.currentTime;
        // Low whoosh
        const osc = ctx.createOscillator();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(200, t);
        osc.frequency.exponentialRampToValueAtTime(60, t + 0.3);
        const gain = ctx.createGain();
        gain.gain.setValueAtTime(0.15, t);
        gain.gain.exponentialRampToValueAtTime(0.001, t + 0.4);
        osc.connect(gain);
        gain.connect(sfxGain);
        osc.start(t);
        osc.stop(t + 0.4);
        // Bubbling noise burst
        const noiseLen = 0.15;
        const buf = ctx.createBuffer(1, ctx.sampleRate * noiseLen, ctx.sampleRate);
        const data = buf.getChannelData(0);
        for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1) * 0.4;
        const noiseSrc = ctx.createBufferSource();
        noiseSrc.buffer = buf;
        const noiseGain = ctx.createGain();
        noiseGain.gain.setValueAtTime(0.1, t + 0.05);
        noiseGain.gain.exponentialRampToValueAtTime(0.001, t + 0.2);
        const lpf = ctx.createBiquadFilter();
        lpf.type = 'lowpass';
        lpf.frequency.value = 400;
        noiseSrc.connect(lpf);
        lpf.connect(noiseGain);
        noiseGain.connect(sfxGain);
        noiseSrc.start(t + 0.05);
        noiseSrc.stop(t + 0.05 + noiseLen);
    }

    // Wind chime (occasional, barely perceptible)
    function playWindChime() {
        ensureCtx();
        const chimeNotes = [1318, 1568, 2093, 2637]; // E6, G6, C7, E7
        const note = Utils.pick(chimeNotes);
        const osc = ctx.createOscillator();
        osc.type = 'sine';
        osc.frequency.value = note;

        const gain = ctx.createGain();
        gain.gain.setValueAtTime(0, ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0.02, ctx.currentTime + 0.1);
        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 2);

        osc.connect(gain);
        gain.connect(ambientGain);
        osc.start();
        osc.stop(ctx.currentTime + 2);
    }

    function startAmbient(themeId) {
        ensureCtx();
        stopAmbient();

        const baseFreqs = {
            koi: 65,       // C2 - warm
            tropical: 82,  // E2 - bright
            deep: 55,      // A1 - mysterious
            zen: 73,       // D2 - calm
            ink: 78        // D#2 - impressionistic
        };

        startWaterAmbient();
        startTonalPad(baseFreqs[themeId] || 65, themeId);
        isPlaying = true;
        currentThemeId = themeId;

        // Schedule periodic ambient sounds
        scheduleAmbientSounds(themeId);
    }

    let ambientInterval = null;
    let melodyInterval = null;
    let currentThemeId = 'koi';

    function scheduleAmbientSounds(themeId) {
        if (ambientInterval) clearInterval(ambientInterval);
        if (melodyInterval) clearInterval(melodyInterval);

        // Theme-specific texture sounds (drips, chimes, chirps, etc.)
        ambientInterval = setInterval(() => {
            if (!isPlaying) return;
            if (Math.random() < 0.35) playDrip();
            if (Math.random() < 0.4) playThemeTexture(themeId);
        }, 3000);

        // Musical melody phrases at shorter intervals for more prominence
        const melodyRate = themeId === 'zen' ? 8000 : (themeId === 'deep' ? 7000 : 5000);
        melodyInterval = setInterval(() => {
            if (!isPlaying) return;
            if (Math.random() < 0.7) playThemeMelody(themeId);
        }, melodyRate);
    }

    function stopAmbient() {
        ambientNodes.forEach(n => { try { n.stop(); } catch(e) {} });
        ambientNodes = [];
        isPlaying = false;
        if (ambientInterval) {
            clearInterval(ambientInterval);
            ambientInterval = null;
        }
        if (melodyInterval) {
            clearInterval(melodyInterval);
            melodyInterval = null;
        }
    }

    function setVolume(v) {
        volume = Utils.clamp(v, 0, 1);
        if (masterGain) {
            masterGain.gain.setTargetAtTime(volume, ctx.currentTime, 0.1);
        }
    }

    function getVolume() { return volume; }

    function pause() {
        if (ctx && ctx.state === 'running') ctx.suspend();
    }

    function resume() {
        if (ctx && ctx.state === 'suspended') ctx.resume();
    }

    // Splash screen gentle ambient sound
    let splashNodes = [];
    let splashInterval = null;
    let splashPlaying = false;

    function startSplashAmbient() {
        ensureCtx();
        stopSplashAmbient();
        splashPlaying = true;

        // Soft filtered noise ‚Äî gentle water presence
        const noise = ctx.createBufferSource();
        noise.buffer = createNoise(4);
        noise.loop = true;
        const lpf = ctx.createBiquadFilter();
        lpf.type = 'lowpass';
        lpf.frequency.value = 150;
        const hpf = ctx.createBiquadFilter();
        hpf.type = 'highpass';
        hpf.frequency.value = 30;
        const noiseGain = ctx.createGain();
        noiseGain.gain.value = 0.15;
        noise.connect(hpf);
        hpf.connect(lpf);
        lpf.connect(noiseGain);
        noiseGain.connect(masterGain);
        noise.start();
        splashNodes.push(noise);

        // Soft tonal drone ‚Äî zen-like pad
        const droneFreqs = [65, 97.5]; // C2 and G2 ‚Äî open fifth
        droneFreqs.forEach((freq, i) => {
            const osc = ctx.createOscillator();
            osc.type = 'sine';
            osc.frequency.value = freq;
            const vibrato = ctx.createOscillator();
            vibrato.type = 'sine';
            vibrato.frequency.value = 0.04;
            const vibGain = ctx.createGain();
            vibGain.gain.value = 1;
            vibrato.connect(vibGain);
            vibGain.connect(osc.frequency);
            const gain = ctx.createGain();
            gain.gain.value = i === 0 ? 0.08 : 0.04;
            osc.connect(gain);
            gain.connect(masterGain);
            osc.start();
            vibrato.start();
            splashNodes.push(osc, vibrato);
        });

        // Occasional gentle chime/bell tones
        splashInterval = setInterval(() => {
            if (!splashPlaying || !ctx) return;
            if (Math.random() < 0.4) {
                const notes = [523, 659, 784, 1047]; // C5, E5, G5, C6
                const f = Utils.pick(notes);
                const osc = ctx.createOscillator();
                osc.type = 'sine';
                osc.frequency.value = f;
                const gain = ctx.createGain();
                gain.gain.setValueAtTime(0, ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0.025, ctx.currentTime + 0.1);
                gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 3);
                osc.connect(gain);
                gain.connect(masterGain);
                osc.start();
                osc.stop(ctx.currentTime + 3);
            }
        }, 4000);
    }

    function stopSplashAmbient() {
        splashNodes.forEach(n => { try { n.stop(); } catch(e) {} });
        splashNodes = [];
        splashPlaying = false;
        if (splashInterval) {
            clearInterval(splashInterval);
            splashInterval = null;
        }
    }

    return {
        init, startAmbient, stopAmbient, setVolume, getVolume,
        startSplashAmbient, stopSplashAmbient,
        playPlop, playBirth, playEaten, playCleaning, playDrip, playBubble, playTapGlass,
        playStingerRelease, playInkSquirt,
        pause, resume, ensureCtx
    };
})();


/* ============================================
   ZENQUARIUM - Theme Definitions
   ============================================ */

const Themes = (() => {

    const themes = {
        koi: {
            id: 'koi',
            name: 'Koi Garden',
            description: 'Cherry blossoms & warm sunset',
            cssClass: 'theme-koi',
            cardBg: 'linear-gradient(135deg, #1a3a5c, #2a1f14)',
            fishTypes: [
                { id: 'koi-orange', name: 'Orange Koi', bodyColor: '#e8845c', finColor: '#d4742c', accentColor: '#fff5e6', cost: 20, size: 1.2, speed: 0.7, shape: 'standard', aggression: 0.3, traits: ['social', 'lazy'], personality: 'Social & easygoing' },
                { id: 'koi-white', name: 'White Koi', bodyColor: '#f0e6d4', finColor: '#d4c8b0', accentColor: '#ffffff', cost: 25, size: 1.3, speed: 0.6, shape: 'standard', aggression: 0.2, traits: ['shy', 'explorer'], personality: 'Shy but adventurous' },
                { id: 'koi-red', name: 'Red Koi', bodyColor: '#c94040', finColor: '#a03030', accentColor: '#f0d0d0', cost: 30, size: 1.1, speed: 0.8, shape: 'round', aggression: 0.5, traits: ['brave', 'greedy'], personality: 'Bold & competitive' },
                { id: 'goldfish', name: 'Goldfish', bodyColor: '#f0a830', finColor: '#d4901c', accentColor: '#fff0c0', cost: 15, size: 0.8, speed: 1.0, shape: 'round', aggression: 0.2, traits: ['playful', 'curious'], personality: 'Playful & curious' },
            ],
            plantColors: ['#2d5a3a', '#3a7048', '#1a3d28', '#4a8858', '#5c9a6a', '#3d8050', '#1e4830', '#6aad78'],
            bubbleColor: 'rgba(255,255,255,0.15)',
            particleColor: 'rgba(255, 220, 180, 0.06)',
            // Cherry blossom petals
            hasSpecialParticles: true,
            specialParticle: { color: '#f0c0c0', shape: 'petal' }
        },

        tropical: {
            id: 'tropical',
            name: 'Tropical Reef',
            description: 'Vibrant coral & tropical fish',
            cssClass: 'theme-tropical',
            cardBg: 'linear-gradient(135deg, #0a4a6e, #3a2a18)',
            fishTypes: [
                { id: 'clown', name: 'Clownfish', bodyColor: '#f07020', finColor: '#1a1a1a', accentColor: '#ffffff', cost: 20, size: 0.8, speed: 1.2, shape: 'round', aggression: 0.4, traits: ['playful', 'brave'], personality: 'Playful & fearless' },
                { id: 'tang', name: 'Blue Tang', bodyColor: '#1870cc', finColor: '#f0d020', accentColor: '#f0e040', cost: 25, size: 1.0, speed: 1.0, shape: 'slim', aggression: 0.6, traits: ['explorer', 'brave'], personality: 'Bold explorer' },
                { id: 'angel', name: 'Angelfish', bodyColor: '#d8d8d0', finColor: '#c0c0b8', accentColor: '#303030', cost: 30, size: 1.2, speed: 0.8, shape: 'tall', aggression: 0.7, traits: ['greedy', 'brave'], personality: 'Dominant & hungry' },
                { id: 'neon', name: 'Neon Tetra', bodyColor: '#a8c8d8', finColor: '#88b0c8', accentColor: '#e04040', cost: 10, size: 0.6, speed: 1.5, shape: 'slim', aggression: 0.1, traits: ['shy', 'social'], personality: 'Timid schooler' },
            ],
            plantColors: ['#e04060', '#f06080', '#d03050', '#c02040', '#ff8040', '#e8a020', '#d050d0', '#50d0a0'],
            bubbleColor: 'rgba(100,220,255,0.15)',
            particleColor: 'rgba(100, 220, 255, 0.04)',
            hasSpecialParticles: false
        },

        deep: {
            id: 'deep',
            name: 'Deep Ocean',
            description: 'Bioluminescent mysteries',
            cssClass: 'theme-deep',
            cardBg: 'linear-gradient(135deg, #060d18, #0a0f18)',
            fishTypes: [
                { id: 'angler', name: 'Anglerfish', bodyColor: '#3a5070', finColor: '#2a3858', accentColor: '#00ffcc', cost: 30, size: 1.4, speed: 0.5, shape: 'round', aggression: 0.9, glowColor: 'rgba(0,255,204,0.2)', traits: ['lazy', 'greedy'], personality: 'Patient predator' },
                { id: 'jelly', name: 'Jellyfish', bodyColor: '#9050e8', finColor: '#7040c0', accentColor: '#e0a0ff', cost: 20, size: 0.9, speed: 0.4, shape: 'tall', aggression: 0.1, glowColor: 'rgba(224,160,255,0.2)', traits: ['shy', 'explorer'], personality: 'Drifting loner' },
                { id: 'lantern', name: 'Lanternfish', bodyColor: '#2878a8', finColor: '#1a5880', accentColor: '#80ff80', cost: 15, size: 0.6, speed: 1.1, shape: 'slim', aggression: 0.3, glowColor: 'rgba(128,255,128,0.2)', traits: ['social', 'playful'], personality: 'Friendly & lively' },
                { id: 'biolum', name: 'Glowfin', bodyColor: '#1a4a2a', finColor: '#0d3a1a', accentColor: '#39ff14', cost: 25, size: 0.8, speed: 0.9, shape: 'standard', aggression: 0.4, glowColor: 'rgba(57,255,20,0.25)', traits: ['curious', 'explorer'], personality: 'Inquisitive roamer' },
            ],
            plantColors: ['#1a3040', '#203848', '#0d1a28', '#284050', '#1a4858', '#0a2838', '#305868', '#183848'],
            bubbleColor: 'rgba(77,201,246,0.1)',
            particleColor: 'rgba(77, 201, 246, 0.03)',
            hasSpecialParticles: true,
            specialParticle: { color: '#4dc9f6', shape: 'glow' },
            fishGlow: true
        },

        zen: {
            id: 'zen',
            name: 'Zen Garden',
            description: 'Minimalist tranquility',
            cssClass: 'theme-zen',
            cardBg: 'linear-gradient(135deg, #1a1a1a, #1a1810)',
            fishTypes: [
                { id: 'zen-gold', name: 'Golden Carp', bodyColor: '#d4742c', finColor: '#b05820', accentColor: '#f0d8a0', cost: 25, size: 1.0, speed: 0.6, shape: 'standard', aggression: 0.3, glowColor: 'rgba(240,216,160,0.12)', traits: ['lazy', 'social'], personality: 'Calm companion' },
                { id: 'zen-silver', name: 'Silver Minnow', bodyColor: '#909898', finColor: '#707878', accentColor: '#c0c8c8', cost: 15, size: 0.6, speed: 1.2, shape: 'slim', aggression: 0.2, glowColor: 'rgba(192,200,200,0.1)', traits: ['playful', 'explorer'], personality: 'Restless spirit' },
                { id: 'zen-black', name: 'Ink Koi', bodyColor: '#282828', finColor: '#1a1a1a', accentColor: '#505050', cost: 30, size: 1.2, speed: 0.5, shape: 'round', aggression: 0.6, glowColor: 'rgba(120,120,120,0.18)', traits: ['brave', 'greedy'], personality: 'Silent authority' },
                { id: 'zen-white', name: 'Pearl Koi', bodyColor: '#e8e0d0', finColor: '#d0c8b8', accentColor: '#ffffff', cost: 20, size: 1.1, speed: 0.7, shape: 'standard', aggression: 0.2, glowColor: 'rgba(255,255,255,0.1)', traits: ['curious', 'shy'], personality: 'Gentle observer' },
            ],
            plantColors: ['#2a2a20', '#343428', '#1a1a14', '#3a3a30', '#3d3a28', '#282818', '#4a4838', '#2e3020'],
            bubbleColor: 'rgba(255,255,255,0.08)',
            particleColor: 'rgba(255, 255, 255, 0.03)',
            hasSpecialParticles: false,
            fishGlow: true
        },

        ink: {
            id: 'ink',
            name: 'Pen & Ink',
            description: 'Elegant line drawings',
            cssClass: 'theme-ink',
            cardBg: 'linear-gradient(135deg, #2a2520, #1a1815)',
            fishTypes: [
                { id: 'ink-koi', name: 'Ink Koi', bodyColor: 'none', finColor: 'none', accentColor: '#5c3a1a', cost: 20, size: 1.1, speed: 0.7, shape: 'standard', aggression: 0.3, inkStyle: true, inkWash: 'rgba(92,58,26,0.06)', traits: ['social', 'lazy'], personality: 'Contemplative soul' },
                { id: 'ink-angel', name: 'Sketch Angel', bodyColor: 'none', finColor: 'none', accentColor: '#2a3a6a', cost: 25, size: 1.0, speed: 0.8, shape: 'tall', aggression: 0.5, inkStyle: true, inkWash: 'rgba(42,58,106,0.06)', traits: ['curious', 'explorer'], personality: 'Wandering artist' },
                { id: 'ink-tetra', name: 'Line Tetra', bodyColor: 'none', finColor: 'none', accentColor: '#2a5a3a', cost: 15, size: 0.6, speed: 1.3, shape: 'slim', aggression: 0.1, inkStyle: true, inkWash: 'rgba(42,90,58,0.06)', traits: ['playful', 'social'], personality: 'Energetic schooler' },
                { id: 'ink-puffer', name: 'Doodle Puffer', bodyColor: 'none', finColor: 'none', accentColor: '#8a3a2a', cost: 30, size: 0.9, speed: 0.5, shape: 'round', aggression: 0.4, inkStyle: true, inkWash: 'rgba(138,58,42,0.06)', traits: ['shy', 'brave'], personality: 'Cautious but tough' },
            ],
            plantColors: ['#3a3a3a', '#4a4a4a', '#2a2a2a', '#5a5a5a', '#6a6a6a', '#1a1a1a'],
            bubbleColor: 'rgba(42,42,42,0.12)',
            particleColor: 'rgba(42, 42, 42, 0.04)',
            hasSpecialParticles: false,
            inkTheme: true
        }
    };

    function getTheme(id) {
        return themes[id] || themes.koi;
    }

    function getAllThemes() {
        return Object.values(themes);
    }

    function applyTheme(id) {
        const theme = getTheme(id);
        document.body.className = theme.cssClass;
        return theme;
    }

    return { getTheme, getAllThemes, applyTheme };
})();


/* ============================================
   ZENQUARIUM - Fish System
   ============================================ */

class Fish {
    constructor(typeInfo, tankW, tankH, isBaby = false) {
        this.id = Utils.uid();
        this.type = typeInfo.id;
        this.typeName = typeInfo.name;
        this.bodyColor = typeInfo.bodyColor;
        this.finColor = typeInfo.finColor;
        this.accentColor = typeInfo.accentColor;
        this.shape = typeInfo.shape || 'standard';
        this.aggression = typeInfo.aggression || 0.3;
        this.inkStyle = typeInfo.inkStyle || false;
        this.inkWash = typeInfo.inkWash || null;
        this.glowColor = typeInfo.glowColor || null;

        // Size with personality variation, scaled for tank width
        const tankScale = Fish.tankScale(tankW);
        this.baseSize = typeInfo.size * (isBaby ? 0.3 : Utils.rand(0.85, 1.15)) * tankScale;
        this.size = this.baseSize;
        this.isBaby = isBaby;
        this.growthProgress = isBaby ? 0 : 1;

        // Position
        this.x = Utils.rand(100, tankW - 100);
        this.y = Utils.rand(80, tankH - 120);
        this.tankW = tankW;
        this.tankH = tankH;

        // Movement
        this.baseSpeed = typeInfo.speed * Utils.rand(0.8, 1.2);
        this.speed = this.baseSpeed;
        this.vx = Utils.rand(-1, 1) * this.speed;
        this.vy = Utils.rand(-0.5, 0.5) * this.speed;
        this.facingRight = this.vx >= 0;
        this.targetX = this.x;
        this.targetY = this.y;
        this.nextTargetTime = 0;
        this.dartCooldown = 0;

        // State
        this.hunger = 50; // 0 = starving, 100 = full
        this.health = 100;
        this.happiness = 80;
        this.age = isBaby ? 0 : Utils.rand(50, 100);
        this.alive = true;

        // Pursuit
        this.pursuingFood = null;
        this.pursuingPrey = null;

        // Animation
        this.tailPhase = Math.random() * Math.PI * 2;
        this.bodyWave = 0;
        this.finPhase = Math.random() * Math.PI * 2;

        // Bubble emission
        this.bubbleTimer = Utils.rand(5, 15);
        this.isBubbling = false;
        this.bubbleDuration = 0;
        this.bubbleCount = 0;

        // Personality traits ‚Äî type-based with individual intensity variation
        this.traits = typeInfo.traits || [];
        this.traitIntensity = {};
        this.traits.forEach(t => {
            this.traitIntensity[t] = Utils.rand(0.7, 1.3);
        });

        // Lazy fish are inherently much slower
        if (this.traitIntensity['lazy']) {
            this.baseSpeed *= (1 - 0.35 * this.traitIntensity['lazy']);
            this.speed = this.baseSpeed;
        }

        // SVG element
        this.el = null;
        this.createSVG();
    }

    hasTrait(name) { return this.traitIntensity[name] || 0; }

    createSVG() {
        const g = Utils.svgEl('g', { class: 'fish-group', id: this.id });

        const scale = this.size * 40;
        const w = scale * 2;
        const h = scale;

        // Shadow
        const shadow = Utils.svgEl('ellipse', {
            cx: 0, cy: h * 0.6,
            rx: w * 0.35, ry: h * 0.08,
            fill: 'rgba(0,0,0,0.15)',
            class: 'fish-shadow'
        });
        g.appendChild(shadow);

        // Glow outline for dark-on-dark themes
        if (this.glowColor) {
            const glow = Utils.svgEl('ellipse', {
                cx: 0, cy: 0,
                rx: w * 0.48, ry: h * 0.48,
                fill: this.glowColor,
                class: 'fish-glow'
            });
            g.appendChild(glow);
        }

        // Tail fin
        this.tailEl = Utils.svgEl('path', {
            d: `M ${-w*0.35} 0 Q ${-w*0.55} ${-h*0.35}, ${-w*0.65} ${-h*0.3} Q ${-w*0.45} 0, ${-w*0.65} ${h*0.3} Q ${-w*0.55} ${h*0.35}, ${-w*0.35} 0 Z`,
            fill: this.finColor,
            opacity: '0.8',
            class: 'fish-tail'
        });
        this.tailBaseX = -w * 0.35;
        g.appendChild(this.tailEl);

        // Body
        let bodyRx = w * 0.38;
        let bodyRy = h * 0.38;
        if (this.shape === 'round') { bodyRx = w * 0.32; bodyRy = h * 0.42; }
        else if (this.shape === 'slim') { bodyRx = w * 0.42; bodyRy = h * 0.25; }
        else if (this.shape === 'tall') { bodyRx = w * 0.25; bodyRy = h * 0.48; }
        const body = Utils.svgEl('ellipse', {
            cx: 0, cy: 0,
            rx: bodyRx, ry: bodyRy,
            fill: this.bodyColor,
            class: 'fish-body-path'
        });
        g.appendChild(body);

        // Body sheen
        const sheen = Utils.svgEl('ellipse', {
            cx: w * 0.05, cy: -h * 0.08,
            rx: w * 0.25, ry: h * 0.18,
            fill: this.accentColor,
            opacity: '0.15'
        });
        g.appendChild(sheen);

        // Neon Tetra signature stripes ‚Äî iridescent blue front + red rear
        if (this.type === 'neon') {
            // Bright neon blue lateral stripe (nose to mid-body)
            const neonStripe = Utils.svgEl('path', {
                d: `M ${bodyRx * 0.9} ${-bodyRy * 0.05} Q ${bodyRx * 0.3} ${-bodyRy * 0.15}, ${-bodyRx * 0.15} 0`,
                stroke: '#00d4ff',
                'stroke-width': (bodyRy * 0.22).toFixed(1),
                'stroke-linecap': 'round',
                fill: 'none',
                opacity: '0.85'
            });
            g.appendChild(neonStripe);
            // Red rear stripe (mid-body to tail)
            const redStripe = Utils.svgEl('path', {
                d: `M ${-bodyRx * 0.05} ${bodyRy * 0.05} Q ${-bodyRx * 0.5} ${bodyRy * 0.1}, ${-bodyRx * 0.95} ${bodyRy * 0.02}`,
                stroke: '#e83030',
                'stroke-width': (bodyRy * 0.28).toFixed(1),
                'stroke-linecap': 'round',
                fill: 'none',
                opacity: '0.8'
            });
            g.appendChild(redStripe);
        }

        // Clownfish signature ‚Äî 3 white bars with black edges
        if (this.type === 'clown') {
            const barPositions = [-0.55, 0.0, 0.5];
            barPositions.forEach(pos => {
                const bx = bodyRx * pos;
                // Black outline bar
                const outline = Utils.svgEl('path', {
                    d: `M ${bx} ${-bodyRy * 0.95} L ${bx} ${bodyRy * 0.95}`,
                    stroke: '#1a1a1a',
                    'stroke-width': (bodyRy * 0.28).toFixed(1),
                    'stroke-linecap': 'round',
                    fill: 'none',
                    opacity: '0.7'
                });
                g.appendChild(outline);
                // White bar on top
                const bar = Utils.svgEl('path', {
                    d: `M ${bx} ${-bodyRy * 0.85} L ${bx} ${bodyRy * 0.85}`,
                    stroke: '#ffffff',
                    'stroke-width': (bodyRy * 0.18).toFixed(1),
                    'stroke-linecap': 'round',
                    fill: 'none',
                    opacity: '0.9'
                });
                g.appendChild(bar);
            });
        }

        // Blue Tang signature ‚Äî dark palette curve + yellow tail accent
        if (this.type === 'tang') {
            // Black "6" shaped marking from eye area sweeping to tail
            const mark = Utils.svgEl('path', {
                d: `M ${-bodyRx * 0.7} ${-bodyRy * 0.2} Q ${-bodyRx * 0.2} ${-bodyRy * 0.6}, ${bodyRx * 0.3} ${-bodyRy * 0.3} Q ${bodyRx * 0.7} ${-bodyRy * 0.1}, ${bodyRx * 0.85} ${bodyRy * 0.15} Q ${bodyRx * 0.6} ${bodyRy * 0.6}, ${bodyRx * 0.1} ${bodyRy * 0.4} Q ${-bodyRx * 0.3} ${bodyRy * 0.2}, ${-bodyRx * 0.7} ${-bodyRy * 0.2}Z`,
                fill: 'rgba(10,10,30,0.55)',
                stroke: 'none'
            });
            g.appendChild(mark);
            // Yellow tail accent
            const tailGlow = Utils.svgEl('path', {
                d: `M ${bodyRx * 0.65} ${-bodyRy * 0.15} Q ${bodyRx * 1.0} 0, ${bodyRx * 0.65} ${bodyRy * 0.15}`,
                stroke: '#f0d020',
                'stroke-width': (bodyRy * 0.25).toFixed(1),
                'stroke-linecap': 'round',
                fill: 'none',
                opacity: '0.85'
            });
            g.appendChild(tailGlow);
        }

        // Angelfish signature ‚Äî dark vertical stripes on silver body
        if (this.type === 'angel') {
            const stripePositions = [-0.45, -0.1, 0.25, 0.55];
            stripePositions.forEach((pos, i) => {
                const sx = bodyRx * pos;
                // Stripes taper toward edges of body
                const heightScale = 1 - Math.abs(pos) * 0.35;
                const stripe = Utils.svgEl('path', {
                    d: `M ${sx} ${-bodyRy * heightScale * 0.9} L ${sx} ${bodyRy * heightScale * 0.9}`,
                    stroke: i === 0 ? '#2a2a2a' : '#3a3a3a',
                    'stroke-width': (bodyRy * (i === 0 ? 0.18 : 0.13)).toFixed(1),
                    'stroke-linecap': 'round',
                    fill: 'none',
                    opacity: i === 0 ? '0.75' : '0.55'
                });
                g.appendChild(stripe);
            });
            // Tall sail-like dorsal fin
            const sailFin = Utils.svgEl('path', {
                d: `M ${-w*0.15} ${-bodyRy * 0.85} Q ${-w*0.05} ${-h*1.1}, ${w*0.12} ${-h*0.95} Q ${w*0.18} ${-bodyRy * 0.7}, ${w*0.2} ${-bodyRy * 0.55}`,
                fill: this.finColor,
                stroke: '#b0b0a8',
                'stroke-width': '0.5',
                opacity: '0.75'
            });
            g.appendChild(sailFin);
            // Long trailing ventral whiskers (2 filaments)
            const whisker1 = Utils.svgEl('path', {
                d: `M ${-w*0.02} ${bodyRy * 0.6} Q ${-w*0.08} ${h*0.9}, ${-w*0.15} ${h*1.3}`,
                stroke: this.finColor,
                'stroke-width': '1.2',
                'stroke-linecap': 'round',
                fill: 'none',
                opacity: '0.6',
                class: 'tentacle'
            });
            g.appendChild(whisker1);
            const whisker2 = Utils.svgEl('path', {
                d: `M ${w*0.02} ${bodyRy * 0.55} Q ${w*0.05} ${h*0.85}, ${w*0.0} ${h*1.25}`,
                stroke: this.finColor,
                'stroke-width': '1',
                'stroke-linecap': 'round',
                fill: 'none',
                opacity: '0.5',
                class: 'tentacle'
            });
            g.appendChild(whisker2);
        }

        // Ink style: convert to elegant brush-stroke line drawing
        if (this.inkStyle) {
            // Body: delicate wash with refined brush stroke outline
            body.setAttribute('fill', this.inkWash || 'none');
            body.setAttribute('stroke', this.accentColor);
            body.setAttribute('stroke-width', '1.5');
            body.setAttribute('stroke-linecap', 'round');
            body.setAttribute('stroke-linejoin', 'round');

            // Shadow becomes a light ink suggestion line
            shadow.setAttribute('fill', 'none');
            shadow.setAttribute('stroke', this.accentColor);
            shadow.setAttribute('stroke-width', '0.3');
            shadow.setAttribute('opacity', '0.15');
            shadow.setAttribute('stroke-dasharray', '6,8');

            // Tail: flowing brush-like stroke
            this.tailEl.setAttribute('fill', this.inkWash || 'none');
            this.tailEl.setAttribute('stroke', this.accentColor);
            this.tailEl.setAttribute('stroke-width', '1.2');
            this.tailEl.setAttribute('stroke-linecap', 'round');

            // Sheen as calligraphic accent
            sheen.setAttribute('fill', 'none');
            sheen.setAttribute('stroke', this.accentColor);
            sheen.setAttribute('stroke-width', '0.3');
            sheen.setAttribute('opacity', '0.12');
            sheen.setAttribute('stroke-dasharray', '1,6');

            // Elegant flowing contour line ‚Äî slightly offset for hand-drawn feel
            const contourOffset = Utils.rand(0.3, 0.8);
            const contour = Utils.svgEl('ellipse', {
                cx: contourOffset, cy: contourOffset * 0.5,
                rx: bodyRx + Utils.rand(1, 2.5), ry: bodyRy + Utils.rand(0.5, 1.5),
                fill: 'none',
                stroke: this.accentColor,
                'stroke-width': Utils.rand(0.2, 0.5).toFixed(1),
                opacity: '0.18'
            });
            g.appendChild(contour);

            // Inner body curve ‚Äî like a brush sweep showing volume
            const innerCurve = Utils.svgEl('path', {
                d: `M ${-bodyRx * 0.6} ${-bodyRy * 0.1} Q ${-bodyRx * 0.1} ${-bodyRy * 0.5}, ${bodyRx * 0.4} ${-bodyRy * 0.15}`,
                stroke: this.accentColor,
                'stroke-width': '0.6',
                'stroke-linecap': 'round',
                fill: 'none',
                opacity: '0.2'
            });
            g.appendChild(innerCurve);

            // Flowing belly line
            const bellyLine = Utils.svgEl('path', {
                d: `M ${-bodyRx * 0.5} ${bodyRy * 0.3} Q ${0} ${bodyRy * 0.6}, ${bodyRx * 0.5} ${bodyRy * 0.2}`,
                stroke: this.accentColor,
                'stroke-width': '0.4',
                'stroke-linecap': 'round',
                fill: 'none',
                opacity: '0.15'
            });
            g.appendChild(bellyLine);
        }

        // Dorsal fin
        this.dorsalEl = Utils.svgEl('path', {
            d: `M ${-w*0.1} ${-h*0.35} Q 0 ${-h*0.6}, ${w*0.15} ${-h*0.35}`,
            fill: this.finColor,
            opacity: '0.7',
            class: 'fish-dorsal-fin'
        });
        g.appendChild(this.dorsalEl);

        // Pectoral fin
        this.pectoralEl = Utils.svgEl('path', {
            d: `M ${w*0.05} ${h*0.1} Q ${w*0.15} ${h*0.35}, ${-w*0.05} ${h*0.3}`,
            fill: this.finColor,
            opacity: '0.6',
            class: 'fish-pectoral-fin'
        });
        g.appendChild(this.pectoralEl);
        this.fishW = w;
        this.fishH = h;

        // Eye
        const eyeX = w * 0.2;
        const eyeY = -h * 0.05;
        const eyeOuter = Utils.svgEl('circle', {
            cx: eyeX, cy: eyeY, r: h * 0.08,
            fill: '#ffffff'
        });
        g.appendChild(eyeOuter);
        const eyeInner = Utils.svgEl('circle', {
            cx: eyeX + h * 0.02, cy: eyeY, r: h * 0.04,
            fill: '#1a1a2e'
        });
        g.appendChild(eyeInner);

        // Mouth (subtle)
        const mouth = Utils.svgEl('path', {
            d: `M ${w*0.35} ${h*0.02} Q ${w*0.37} ${h*0.06}, ${w*0.34} ${h*0.08}`,
            stroke: 'rgba(0,0,0,0.3)',
            'stroke-width': '1',
            fill: 'none'
        });
        g.appendChild(mouth);

        if (this.inkStyle) {
            // Fins: refined calligraphic strokes
            this.dorsalEl.setAttribute('fill', this.inkWash || 'none');
            this.dorsalEl.setAttribute('stroke', this.accentColor);
            this.dorsalEl.setAttribute('stroke-width', '1.1');
            this.dorsalEl.setAttribute('stroke-linecap', 'round');
            this.pectoralEl.setAttribute('fill', 'none');
            this.pectoralEl.setAttribute('stroke', this.accentColor);
            this.pectoralEl.setAttribute('stroke-width', '0.8');
            this.pectoralEl.setAttribute('stroke-linecap', 'round');

            // Eye: refined ink circle with pupil dot
            eyeOuter.setAttribute('fill', 'none');
            eyeOuter.setAttribute('stroke', this.accentColor);
            eyeOuter.setAttribute('stroke-width', '1');
            eyeInner.setAttribute('fill', this.accentColor);

            // Mouth: delicate ink line
            mouth.setAttribute('stroke', this.accentColor);
            mouth.setAttribute('stroke-width', '0.8');
            mouth.setAttribute('opacity', '0.6');

            // Sparse, elegant cross-hatching ‚Äî like pen strokes for shading
            const hatchCount = Utils.randInt(3, 5);
            for (let hi = 0; hi < hatchCount; hi++) {
                const hx = Utils.rand(-bodyRx * 0.5, bodyRx * 0.3);
                const hy = Utils.rand(-bodyRy * 0.2, bodyRy * 0.3);
                const len = Utils.rand(4, 8);
                const angle = Utils.rand(0.3, 0.8); // consistent diagonal direction
                const hline = Utils.svgEl('line', {
                    x1: hx - len * Math.cos(angle), y1: hy - len * Math.sin(angle),
                    x2: hx + len * Math.cos(angle), y2: hy + len * Math.sin(angle),
                    stroke: this.accentColor,
                    'stroke-width': Utils.rand(0.2, 0.5).toFixed(1),
                    'stroke-linecap': 'round',
                    opacity: Utils.rand(0.1, 0.25).toFixed(2)
                });
                g.appendChild(hline);
            }

            // Fine stippling ‚Äî concentrated along belly for volume
            const stippleCount = Utils.randInt(4, 8);
            for (let si = 0; si < stippleCount; si++) {
                const sx = Utils.rand(-bodyRx * 0.4, bodyRx * 0.2);
                const sy = Utils.rand(0, bodyRy * 0.5); // mostly below center
                const dot = Utils.svgEl('circle', {
                    cx: sx, cy: sy,
                    r: Utils.rand(0.2, 0.5),
                    fill: this.accentColor,
                    opacity: Utils.rand(0.08, 0.22).toFixed(2)
                });
                g.appendChild(dot);
            }

            // Elegant dorsal fin spine lines
            for (let fi = 0; fi < 3; fi++) {
                const fx = Utils.rand(-w * 0.08, w * 0.12);
                const spine = Utils.svgEl('path', {
                    d: `M ${fx} ${-h*0.35} Q ${fx + Utils.rand(-2,2)} ${-h*(0.42 + fi*0.04)}, ${fx + Utils.rand(1,4)} ${-h*0.35}`,
                    stroke: this.accentColor,
                    'stroke-width': '0.3',
                    'stroke-linecap': 'round',
                    fill: 'none',
                    opacity: Utils.rand(0.12, 0.2).toFixed(2)
                });
                g.appendChild(spine);
            }

            // Tail fin detail lines ‚Äî flowing strokes
            const tailX = this.tailBaseX || -w * 0.3;
            for (let ti = 0; ti < 2; ti++) {
                const ty = Utils.rand(-h * 0.15, h * 0.15);
                const tailStroke = Utils.svgEl('path', {
                    d: `M ${tailX} ${ty} Q ${tailX - w*0.08} ${ty + Utils.rand(-3,3)}, ${tailX - w*0.12} ${ty + Utils.rand(-5,5)}`,
                    stroke: this.accentColor,
                    'stroke-width': '0.3',
                    'stroke-linecap': 'round',
                    fill: 'none',
                    opacity: '0.18'
                });
                g.appendChild(tailStroke);
            }
        }

        this.el = g;
        this.updateTransform();
    }

    updateTransform() {
        const scaleX = this.facingRight ? 1 : -1;
        let sizeRatio = this.isBaby ? 0.3 + this.growthProgress * 0.7 : 1;

        // Brave puff-up: temporarily scale larger when confronting
        if (this._puffUp > 0) {
            sizeRatio *= 1 + this._puffUp * 0.2;
            this._puffUp -= 0.016;
        }

        // Shy flinch: quick shrink-and-recover
        if (this._flinch > 0) {
            sizeRatio *= 0.85 + this._flinch * 0.15;
            this._flinch -= 0.02;
        }

        // Barrel roll for playful fish ‚Äî full 360¬∞ rotation over ~0.4s
        let rollAngle = 0;
        if (this._barrelRoll) {
            if (!this._rollProgress) this._rollProgress = 0;
            this._rollProgress += 0.05;
            rollAngle = this._rollProgress * 360;
            if (this._rollProgress >= 1) {
                this._barrelRoll = false;
                this._rollProgress = 0;
                rollAngle = 0;
            }
        }

        // Lazy rocking: gentle rhythmic swaying when idle
        let rockAngle = 0;
        if (this.hasTrait('lazy') && this.dartCooldown <= 0 && !this.pursuingFood) {
            rockAngle = Math.sin(performance.now() * 0.001 * this.hasTrait('lazy')) * 5;
        }

        this.el.setAttribute('transform',
            `translate(${this.x}, ${this.y}) scale(${scaleX * sizeRatio}, ${sizeRatio}) rotate(${rollAngle + rockAngle})`
        );
        // Animate tail by rotating around where it connects to the body
        if (this.tailEl) {
            const angle = Math.sin(this.tailPhase) * 10;
            this.tailEl.setAttribute('transform',
                `rotate(${angle}, ${this.tailBaseX}, 0)`
            );
        }
        // Subtle dorsal sway
        if (this.dorsalEl) {
            const skew = Math.sin(this.finPhase) * 3;
            this.dorsalEl.setAttribute('transform', `skewX(${skew})`);
        }
        // Pectoral flap
        if (this.pectoralEl) {
            const angle = Math.sin(this.finPhase * 1.3) * 10;
            this.pectoralEl.setAttribute('transform',
                `rotate(${angle}, ${this.fishW * 0.05}, ${this.fishH * 0.1})`
            );
        }
    }

    emitMouthBubble() {
        // Calculate mouth position in world coordinates
        const scaleX = this.facingRight ? 1 : -1;
        const mouthLocalX = this.fishW * 0.35 * scaleX;
        const mouthLocalY = this.fishH * 0.05;
        const worldX = this.x + mouthLocalX;
        const worldY = this.y + mouthLocalY;

        const bubblesLayer = document.getElementById('bubbles-layer');
        if (!bubblesLayer) return;

        const size = Utils.rand(2, 5);
        const bubble = Utils.svgEl('circle', {
            cx: worldX,
            cy: worldY,
            r: size,
            fill: 'url(#bubble-gradient)',
            opacity: '0.5'
        });
        bubblesLayer.appendChild(bubble);

        // Animate the bubble rising
        const startY = worldY;
        const driftX = Utils.rand(-15, 15);
        const duration = Utils.rand(1.5, 3);
        const startTime = performance.now();

        function animateBubble() {
            const elapsed = (performance.now() - startTime) / 1000;
            const progress = elapsed / duration;
            if (progress >= 1) {
                if (bubble.parentNode) bubble.remove();
                return;
            }
            const newY = startY - progress * 120;
            const newX = worldX + Math.sin(progress * Math.PI * 3) * driftX;
            const newOpacity = 0.5 * (1 - progress);
            const newSize = size * (1 + progress * 0.5);
            bubble.setAttribute('cx', newX);
            bubble.setAttribute('cy', newY);
            bubble.setAttribute('opacity', newOpacity);
            bubble.setAttribute('r', newSize);
            requestAnimationFrame(animateBubble);
        }
        requestAnimationFrame(animateBubble);
    }

    pickNewTarget() {
        const playful = this.hasTrait('playful');
        const lazy = this.hasTrait('lazy');
        const explorer = this.hasTrait('explorer');
        const shyness = this.hasTrait('shy');

        // Playful fish dart frequently and energetically
        const dartChance = playful ? 0.4 * playful : 0.15;
        const isDart = Math.random() < dartChance;
        // Explorer fish roam the full tank
        const baseRange = explorer ? 350 * explorer : 150;
        const range = isDart ? baseRange * 2.5 : baseRange;

        this.targetX = Utils.clamp(
            this.x + Utils.rand(-range, range),
            60, this.tankW - 60
        );
        // Lazy fish strongly prefer lower-mid zone (not bottom), shy fish hug edges
        let yBias = 0;
        if (lazy) yBias = this.tankH * 0.12 * lazy;
        if (shyness) {
            const edgePull = 80 * shyness;
            this.targetX = Utils.clamp(
                this.targetX + (this.x < this.tankW / 2 ? -edgePull : edgePull),
                60, this.tankW - 60
            );
        }
        // Mid-water bias: gently pull targets toward center band of the tank
        const midY = this.tankH * 0.4;
        const midPull = (midY - this.y) * 0.15;
        this.targetY = Utils.clamp(
            this.y + Utils.rand(-range * 0.5, range * 0.5) + yBias + midPull,
            60, this.tankH - 100
        );

        if (isDart) {
            const dartSpeed = playful ? Utils.rand(3, 5) : Utils.rand(2.5, 4);
            this.speed = this.baseSpeed * dartSpeed;
            this.dartCooldown = playful ? Utils.rand(0.1, 0.25) : Utils.rand(0.2, 0.5);
            // Visual: playful fish occasionally barrel roll on fast darts
            if (playful && Math.random() < 0.15) this._barrelRoll = true;
        } else {
            const idleSpeed = lazy ? Utils.rand(0.2, 0.5) : Utils.rand(0.5, 1.2);
            this.speed = this.baseSpeed * idleSpeed;
        }

        const waitTime = lazy ? Utils.rand(3500, 8000) : (explorer ? Utils.rand(800, 1800) : Utils.rand(1500, 4000));
        this.nextTargetTime = performance.now() + waitTime;
    }

    update(dt, foods, allFish) {
        if (!this.alive) return;

        const now = performance.now();

        // Growth for babies
        if (this.isBaby) {
            this.growthProgress = Math.min(1, this.growthProgress + dt * 0.02);
            if (this.growthProgress >= 1) {
                this.isBaby = false;
                this.size = this.baseSize * Utils.rand(0.85, 1.15);
            }
        }

        // Hunger increases over time
        this.hunger = Math.max(0, this.hunger - dt * 1.5);

        // Health based on hunger
        if (this.hunger < 15) {
            this.health = Math.max(0, this.health - dt * 3);
        } else if (this.hunger > 40) {
            this.health = Math.min(100, this.health + dt * 2);
        }

        // Die if health reaches 0
        if (this.health <= 0) {
            this.alive = false;
            return;
        }

        // Dart cooldown
        if (this.dartCooldown > 0) {
            this.dartCooldown -= dt;
            if (this.dartCooldown <= 0) {
                this.speed = this.baseSpeed;
            }
        }

        // Aggression interactions with nearby fish
        if (!this.pursuingFood && !this.pursuingPrey) {
            const bravery = this.hasTrait('brave');
            for (const other of allFish) {
                if (other === this || !other.alive) continue;
                const d = Utils.dist(this.x, this.y, other.x, other.y);
                if (d > 150) continue;

                const aggrDiff = this.aggression - other.aggression;
                if (aggrDiff > 0.15) {
                    if (d < 100) {
                        this.targetX = other.x;
                        this.targetY = other.y;
                        this.speed = this.baseSpeed * 1.5;
                        this.nextTargetTime = performance.now() + 500;
                        // Brave fish puff up when confronting
                        if (bravery) this._puffUp = 0.6;
                        break;
                    }
                } else if (aggrDiff < -0.15) {
                    // Brave fish barely flinch; non-brave flee dramatically
                    const fleeThreshold = bravery ? 120 * (1 - bravery * 0.5) : 120;
                    if (d < fleeThreshold) {
                        const fleeDist = bravery ? 80 : 250;
                        const fleeAngle = Math.atan2(this.y - other.y, this.x - other.x);
                        this.targetX = Utils.clamp(this.x + Math.cos(fleeAngle) * fleeDist, 60, this.tankW - 60);
                        this.targetY = Utils.clamp(this.y + Math.sin(fleeAngle) * fleeDist, 60, this.tankH - 100);
                        this.speed = this.baseSpeed * (bravery ? 1.1 : 2.2);
                        // Shy fish flinch visually
                        if (this.hasTrait('shy')) this._flinch = 0.3;
                        this.nextTargetTime = performance.now() + 800;
                        break;
                    }
                }
            }
        }

        // Social trait ‚Äî gravitate toward same-type fish
        const socialIntensity = this.hasTrait('social');
        if (socialIntensity && !this.pursuingFood && !this.pursuingPrey && this.dartCooldown <= 0) {
            let nearestFriend = null, friendDist = Infinity;
            for (const other of allFish) {
                if (other === this || !other.alive || other.type !== this.type) continue;
                const d = Utils.dist(this.x, this.y, other.x, other.y);
                if (d > 40 && d < 400 && d < friendDist) {
                    friendDist = d;
                    nearestFriend = other;
                }
            }
            if (nearestFriend && friendDist > 60) {
                const angle = Math.atan2(nearestFriend.y - this.y, nearestFriend.x - this.x);
                this.vx += Math.cos(angle) * 0.6 * socialIntensity * dt * 60;
                this.vy += Math.sin(angle) * 0.6 * socialIntensity * dt * 60;
            }
            // Social fish near friends have slower hunger decay + occasional happy bubble
            if (nearestFriend && friendDist < 100) {
                this.hunger = Math.min(100, this.hunger + dt * 0.6 * socialIntensity);
                if (Math.random() < 0.002 * socialIntensity) this.emitMouthBubble();
            }
        }

        // Schooling ‚Äî 3+ of same type form coordinated swimming patterns
        if (!this.pursuingFood && !this.pursuingPrey && this.dartCooldown <= 0) {
            const sameType = allFish.filter(f => f !== this && f.alive && f.type === this.type);
            if (sameType.length >= 2) {
                // Find nearby same-type fish
                const nearby = sameType.filter(f => Utils.dist(this.x, this.y, f.x, f.y) < 250);
                if (nearby.length >= 2) {
                    // Calculate centroid of the school
                    let cx = this.x, cy = this.y;
                    nearby.forEach(f => { cx += f.x; cy += f.y; });
                    cx /= (nearby.length + 1);
                    cy /= (nearby.length + 1);
                    // Bias centroid away from bottom 30% of tank toward mid-water
                    const bottomThreshold = this.tankH * 0.7;
                    if (cy > bottomThreshold) {
                        cy = Utils.lerp(cy, this.tankH * 0.45, 0.15);
                    }
                    // Cohesion: steer toward centroid
                    const cohAngle = Math.atan2(cy - this.y, cx - this.x);
                    const cohStr = 0.3;
                    this.vx += Math.cos(cohAngle) * cohStr * dt * 60;
                    this.vy += Math.sin(cohAngle) * cohStr * dt * 60;
                    // Alignment: match average velocity of school
                    let avgVx = this.vx, avgVy = this.vy;
                    nearby.forEach(f => { avgVx += f.vx; avgVy += f.vy; });
                    avgVx /= (nearby.length + 1);
                    avgVy /= (nearby.length + 1);
                    this.vx = Utils.lerp(this.vx, avgVx, 0.05);
                    this.vy = Utils.lerp(this.vy, avgVy, 0.05);
                    this._schooling = true;
                } else {
                    this._schooling = false;
                }
            }
        }

        // Separation force ‚Äî prevent fish from overlapping
        let sepX = 0, sepY = 0;
        for (const other of allFish) {
            if (other === this || !other.alive) continue;
            const d = Utils.dist(this.x, this.y, other.x, other.y);
            const minDist = (this.size + other.size) * 25 + 15;
            if (d < minDist && d > 0.1) {
                const force = (minDist - d) / minDist;
                sepX += (this.x - other.x) / d * force;
                sepY += (this.y - other.y) / d * force;
            }
        }
        if (sepX !== 0 || sepY !== 0) {
            const sepStr = 2.5;
            this.vx += sepX * sepStr * dt * 60;
            this.vy += sepY * sepStr * dt * 60;
        }

        // Pursue food if hungry ‚Äî greedy fish detect food from far, shy fish from close
        const greedy = this.hasTrait('greedy');
        const shyFood = this.hasTrait('shy');
        const curFood = this.hasTrait('curious');
        const foodDetectRange = greedy ? 700 * greedy : (shyFood ? 200 : (curFood ? 550 * curFood : 400));
        // Reset stale food pursuit ‚Äî food may have been eaten by another fish or decayed
        if (this.pursuingFood && (this.pursuingFood.eaten || !this.pursuingFood.el || !this.pursuingFood.el.parentNode)) {
            this.pursuingFood = null;
        }
        if (this.hunger < 75 && foods.length > 0) {
            let closest = null;
            let closestDist = Infinity;
            for (const food of foods) {
                if (food.eaten) continue;
                const d = Utils.dist(this.x, this.y, food.x, food.y);
                if (d < closestDist && d < foodDetectRange) {
                    closestDist = d;
                    closest = food;
                }
            }
            if (closest) {
                this.pursuingFood = closest;
                this.targetX = closest.x;
                this.targetY = closest.y;
                const foodSpeed = greedy ? 3 * greedy : 2;
                this.speed = this.baseSpeed * foodSpeed;

                // Eat if close enough ‚Äî greedy fish eat from farther away
                const eatDist = greedy ? 30 * greedy : 20;
                if (closestDist < eatDist) {
                    closest.eaten = true;
                    this.hunger = Math.min(100, this.hunger + 30);
                    this.pursuingFood = null;
                }
            }
        }

        // Big fish chase small fish when very hungry
        if (this.hunger < 20 && this.size > 0.9 && !this.isBaby) {
            let prey = null;
            let preyDist = Infinity;
            for (const other of allFish) {
                if (other === this || !other.alive || other.isBaby) continue;
                if (other.size < this.size * 0.7) {
                    const d = Utils.dist(this.x, this.y, other.x, other.y);
                    if (d < preyDist && d < 300) {
                        preyDist = d;
                        prey = other;
                    }
                }
            }
            if (prey) {
                this.pursuingPrey = prey;
                this.targetX = prey.x;
                this.targetY = prey.y;
                this.speed = this.baseSpeed * 2.5;

                if (preyDist < 15) {
                    prey.alive = false;
                    this.hunger = Math.min(100, this.hunger + 50);
                    this.pursuingPrey = null;
                    return prey; // Signal that prey was eaten
                }
            }
        }

        // Curious fish pause and look toward the mouse when it's nearby
        const curiosity = this.hasTrait('curious');
        if (curiosity && this._mouseX > 0 && !this.pursuingFood && !this.pursuingPrey) {
            const mouseDist = Utils.dist(this.x, this.y, this._mouseX, this._mouseY);
            if (mouseDist < 200 * curiosity && mouseDist > 30) {
                // Slow down and face the mouse
                this.speed = this.baseSpeed * 0.2;
                this.facingRight = this._mouseX > this.x;
                // Extend wait time so they linger looking
                this.nextTargetTime = Math.max(this.nextTargetTime, now + 800);
            }
        }

        // Pick new target if needed
        if (now > this.nextTargetTime && !this.pursuingFood && !this.pursuingPrey) {
            this.pickNewTarget();
        }

        // Move toward target
        const dx = this.targetX - this.x;
        const dy = this.targetY - this.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist > 2) {
            const moveSpeed = this.speed * 60 * dt;
            const ratio = Math.min(1, moveSpeed / dist);
            this.vx = Utils.lerp(this.vx, dx * ratio, 0.1);
            this.vy = Utils.lerp(this.vy, dy * ratio, 0.1);
        } else {
            this.vx *= 0.95;
            this.vy *= 0.95;
        }

        // Apply velocity
        this.x += this.vx;
        this.y += this.vy;

        // Soft boundary repulsion ‚Äî push fish away from edges before hard clamp
        const edgeMargin = 80;
        const edgePush = 3.0;
        if (this.x < 40 + edgeMargin) {
            const proximity = 1 - (this.x - 40) / edgeMargin;
            this.vx += proximity * edgePush * dt * 60;
        } else if (this.x > this.tankW - 40 - edgeMargin) {
            const proximity = 1 - (this.tankW - 40 - this.x) / edgeMargin;
            this.vx -= proximity * edgePush * dt * 60;
        }
        if (this.y < 50 + edgeMargin) {
            const proximity = 1 - (this.y - 50) / edgeMargin;
            this.vy += proximity * edgePush * dt * 60;
        } else if (this.y > this.tankH - 80 - edgeMargin) {
            const proximity = 1 - (this.tankH - 80 - this.y) / edgeMargin;
            this.vy -= proximity * edgePush * dt * 60;
        }

        // Boundaries
        this.x = Utils.clamp(this.x, 40, this.tankW - 40);
        this.y = Utils.clamp(this.y, 50, this.tankH - 80);

        // Face direction of movement (never swim backwards)
        if (Math.abs(this.vx) > 0.1) {
            this.facingRight = this.vx > 0;
        }

        // Animation phases
        this.tailPhase += dt * 8 * (0.5 + Math.abs(this.vx) * 0.5);
        this.bodyWave = Math.sin(this.tailPhase) * 0.03;
        this.finPhase += dt * 3;

        // Age
        this.age += dt * 0.5;

        // Bubble emission from mouth
        this.bubbleTimer -= dt;
        if (this.bubbleTimer <= 0 && !this.isBubbling) {
            this.isBubbling = true;
            this.bubbleDuration = Utils.rand(0.8, 1.5);
            this.bubbleCount = 0;
            // Slow down while bubbling
            this.speed = this.baseSpeed * 0.3;
        }

        if (this.isBubbling) {
            this.bubbleDuration -= dt;
            this.bubbleCount += dt;

            // Emit a small bubble every ~0.25 seconds
            if (this.bubbleCount >= 0.25) {
                this.bubbleCount -= 0.25;
                this.emitMouthBubble();
                ZenAudio.playBubble();
            }

            if (this.bubbleDuration <= 0) {
                this.isBubbling = false;
                this.bubbleTimer = Utils.rand(8, 25);
                this.speed = this.baseSpeed;
            }
        }

        this.updateTransform();
        return null;
    }

    resize(tankW, tankH) {
        this.tankW = tankW;
        this.tankH = tankH;
        this.x = Utils.clamp(this.x, 40, tankW - 40);
        this.y = Utils.clamp(this.y, 50, tankH - 80);
    }

    getInfo() {
        return {
            id: this.id,
            type: this.type,
            typeName: this.typeName,
            hunger: this.hunger,
            health: this.health,
            alive: this.alive,
            isBaby: this.isBaby,
            size: this.size,
            bodyColor: this.bodyColor
        };
    }
}

// Scale fish size for smaller screens (reference: 1200px wide = 1.0)
Fish.tankScale = function(tankW) {
    if (tankW >= 1000) return 1;
    return Math.max(0.65, tankW / 1100);
};

// Fish factory
const FishFactory = {
    create(typeInfo, tankW, tankH, isBaby = false) {
        return new Fish(typeInfo, tankW, tankH, isBaby);
    }
};


/* ============================================
   ZENQUARIUM - Tank Environment
   ============================================ */

const Tank = (() => {
    let tankEl, plantsLayer, bubblesLayer, particlesLayer, causticsLayer, lightRaysEl;
    let theme = null;
    let bubbles = [];
    let particles = [];
    let plants = [];
    let tankW = 0, tankH = 0;

    function init(themeData) {
        theme = themeData;
        tankEl = document.getElementById('tank');
        plantsLayer = document.getElementById('plants-layer');
        bubblesLayer = document.getElementById('bubbles-layer');
        particlesLayer = document.getElementById('particles-layer');
        causticsLayer = document.getElementById('caustics-layer');
        lightRaysEl = document.getElementById('light-rays');

        updateSize();
        syncSvgSizes();
        createCaustics();
        createLightRays();
        createPlants();
        createParticles();

        window.addEventListener('resize', Utils.debounce(onResize, 200));
    }

    function updateSize() {
        const rect = tankEl.getBoundingClientRect();
        tankW = rect.width;
        tankH = rect.height;
    }

    function syncSvgSizes() {
        const svgLayers = [
            document.getElementById('water-effects'),
            plantsLayer, 
            document.getElementById('fish-layer'),
            document.getElementById('food-layer'),
            bubblesLayer
        ];
        svgLayers.forEach(svg => {
            if (!svg) return;
            svg.setAttribute('width', tankW);
            svg.setAttribute('height', tankH);
            svg.setAttribute('viewBox', `0 0 ${tankW} ${tankH}`);
        });
    }

    function getSize() { return { w: tankW, h: tankH }; }

    function onResize() {
        updateSize();
        syncSvgSizes();
        clearAll();
        createCaustics();
        createLightRays();
        createPlants();
        createParticles();
    }

    function clearAll() {
        plantsLayer.innerHTML = '';
        particlesLayer.innerHTML = '';
        causticsLayer.innerHTML = '';
        lightRaysEl.innerHTML = '';
        plants = [];
        particles = [];
    }

    // Caustic light patterns
    function createCaustics() {
        const count = 12;
        for (let i = 0; i < count; i++) {
            const x = Utils.rand(0, tankW);
            const y = Utils.rand(0, tankH * 0.6);
            const size = Utils.rand(80, 200);
            const el = Utils.svgEl('ellipse', {
                cx: x, cy: y,
                rx: size, ry: size * 0.6,
                fill: 'var(--caustic-color)',
                class: 'caustic-cell',
                style: `animation-delay: ${Utils.rand(0, 5)}s; animation-duration: ${Utils.rand(4, 8)}s;`
            });
            causticsLayer.appendChild(el);
        }
    }

    // Light rays from surface
    function createLightRays() {
        const count = 5;
        for (let i = 0; i < count; i++) {
            const x = Utils.rand(tankW * 0.1, tankW * 0.9);
            const width = Utils.rand(30, 80);
            const ray = Utils.svgEl('polygon', {
                points: `${x - width/2},0 ${x + width/2},0 ${x + width * 2},${tankH * 0.7} ${x - width},${tankH * 0.7}`,
                fill: 'url(#light-ray)',
                opacity: Utils.rand(0.05, 0.12).toString(),
                style: `animation: causticShimmer ${Utils.rand(6, 12)}s ease-in-out infinite alternate; animation-delay: ${Utils.rand(0, 5)}s;`
            });
            lightRaysEl.appendChild(ray);
        }
    }

    // Aquatic plants
    function createPlants() {
        const plantCount = Utils.randInt(8, 14);
        const colors = theme.plantColors;

        for (let i = 0; i < plantCount; i++) {
            const x = Utils.rand(30, tankW - 30);
            const plantH = tankH * Utils.rand(0.3, 0.5);
            const color1 = Utils.pick(colors);
            const color2 = Utils.pick(colors);
            const swayDuration = Utils.rand(3, 7);
            const swayDelay = Utils.rand(0, 3);
            const swayAmount = Utils.rand(2, 6);

            const gOuter = Utils.svgEl('g', {
                transform: `translate(${x}, ${tankH})`
            });
            const g = Utils.svgEl('g', {
                class: 'plant-group',
                style: `animation: plantSway ${swayDuration}s ease-in-out infinite alternate; animation-delay: ${swayDelay}s;`
            });

            // Main stem with leaves
            const stemCount = Utils.randInt(2, 4);
            for (let s = 0; s < stemCount; s++) {
                const offsetX = Utils.rand(-15, 15);
                const leafH = plantH * Utils.rand(0.6, 1);
                const leafW = Utils.rand(12, 28);
                const color = s % 2 === 0 ? color1 : color2;

                // Stem
                const stem = Utils.svgEl('path', {
                    d: `M ${offsetX} 0 Q ${offsetX + Utils.rand(-10, 10)} ${-leafH * 0.5}, ${offsetX + Utils.rand(-8, 8)} ${-leafH}`,
                    stroke: color,
                    'stroke-width': Utils.rand(3, 6).toString(),
                    fill: 'none',
                    opacity: '0.8'
                });
                g.appendChild(stem);

                // Ink theme: ensure stroke styling
                if (theme.inkTheme) {
                    stem.setAttribute('stroke-dasharray', '');
                    stem.setAttribute('stroke-width', Utils.rand(1, 2.5).toString());
                }

                // Leaves along stem
                const leafCount = Utils.randInt(2, 5);
                for (let l = 0; l < leafCount; l++) {
                    const ly = -(leafH * (l + 1) / (leafCount + 1));
                    const lx = offsetX + Utils.rand(-5, 5);
                    const side = Math.random() > 0.5 ? 1 : -1;
                    const lw = leafW * Utils.rand(0.7, 1.3);
                    const lh = Utils.rand(6, 16);

                    const leaf = Utils.svgEl('path', {
                        d: `M ${lx} ${ly} Q ${lx + side * lw} ${ly - lh}, ${lx + side * lw * 0.6} ${ly - lh * 2}`,
                        stroke: color,
                        'stroke-width': Utils.rand(4, 8).toString(),
                        'stroke-linecap': 'round',
                        fill: 'none',
                        opacity: Utils.rand(0.5, 0.9).toString()
                    });
                    g.appendChild(leaf);

                    // Ink theme: thinner more delicate strokes
                    if (theme.inkTheme) {
                        leaf.setAttribute('stroke-width', Utils.rand(1, 2).toString());
                    }
                }
            }

            gOuter.appendChild(g);
            plantsLayer.appendChild(gOuter);
            plants.push({ el: gOuter, x });
        }

        // Add CSS for plant sway
        if (!document.getElementById('plant-sway-style')) {
            const style = document.createElement('style');
            style.id = 'plant-sway-style';
            style.textContent = `
                @keyframes plantSway {
                    0% { transform: rotate(-2deg); }
                    100% { transform: rotate(2deg); }
                }
            `;
            document.head.appendChild(style);
        }
    }

    // Background particles (dust, plankton)
    function createParticles() {
        const count = 15;
        for (let i = 0; i < count; i++) {
            const el = document.createElement('div');
            el.className = 'particle';
            const size = Utils.rand(1, 3);
            const x = Utils.rand(0, tankW);
            const y = Utils.rand(0, tankH);
            const dx = Utils.rand(-50, 50);
            const dy = Utils.rand(-80, -20);
            const dur = Utils.rand(8, 20);

            el.style.cssText = `
                left: ${x}px; top: ${y}px;
                width: ${size}px; height: ${size}px;
                background: ${theme.particleColor};
                --dx: ${dx}px; --dy: ${dy}px;
                animation-duration: ${dur}s;
                animation-delay: ${Utils.rand(0, dur)}s;
            `;
            particlesLayer.appendChild(el);
            particles.push(el);
        }
    }

    // Spawn a bubble
    function spawnBubble() {
        const x = Utils.rand(40, tankW - 40);
        const size = Utils.rand(3, 10);
        const dur = Utils.rand(4, 8);
        const wobble = Utils.rand(-20, 20);

        const bubble = Utils.svgEl('circle', {
            cx: x, cy: tankH - 60,
            r: size,
            fill: 'url(#bubble-gradient)',
            opacity: Utils.rand(0.2, 0.5).toString(),
            class: 'bubble',
            style: `animation-duration: ${dur}s;`
        });

        bubblesLayer.appendChild(bubble);
        setTimeout(() => {
            if (bubble.parentNode) bubble.remove();
        }, dur * 1000);
    }

    // Update loop
    let bubbleTimer = 0;
    function update(dt) {
        bubbleTimer += dt;
        if (bubbleTimer > Utils.rand(0.5, 2)) {
            spawnBubble();
            bubbleTimer = 0;
            // Occasional bubble cluster
            if (Math.random() < 0.2) {
                for (let i = 0; i < Utils.randInt(2, 4); i++) {
                    setTimeout(() => spawnBubble(), i * 200);
                }
            }
        }
    }

    function setTheme(themeData) {
        theme = themeData;
        clearAll();
        createCaustics();
        createLightRays();
        createPlants();
        createParticles();
    }

    return { init, update, getSize, setTheme, spawnBubble, updateSize, syncSvgSizes };
})();


/* ============================================
   ZENQUARIUM - Food System
   ============================================ */

const Food = (() => {
    let foods = [];
    let foodLayer = null;
    let tankW = 0, tankH = 0;

    function init(w, h) {
        foodLayer = document.getElementById('food-layer');
        tankW = w;
        tankH = h;
    }

    function resize(w, h) {
        tankW = w;
        tankH = h;
    }

    // Drop food flakes into the tank
    function dropFood(count = 5) {
        const centerX = Utils.rand(tankW * 0.2, tankW * 0.8);

        for (let i = 0; i < count; i++) {
            const x = centerX + Utils.rand(-60, 60);
            const y = 10 + Utils.rand(0, 15);
            const size = Utils.rand(3, 7);
            const rotation = Utils.rand(0, 360);
            const fallSpeed = Utils.rand(15, 30);
            const wobbleAmp = Utils.rand(10, 30);
            const wobbleFreq = Utils.rand(1, 3);

            const food = {
                id: Utils.uid(),
                x: x,
                y: y,
                startX: x,
                size: size,
                rotation: rotation,
                fallSpeed: fallSpeed,
                wobbleAmp: wobbleAmp,
                wobbleFreq: wobbleFreq,
                time: 0,
                eaten: false,
                settled: false,
                el: null
            };

            // Create SVG flake
            const g = Utils.svgEl('g', { class: 'food-flake', id: food.id });

            // Irregular flake shape
            const points = [];
            const segments = Utils.randInt(5, 8);
            for (let s = 0; s < segments; s++) {
                const angle = (s / segments) * Math.PI * 2;
                const r = size * Utils.rand(0.5, 1);
                points.push(`${Math.cos(angle) * r},${Math.sin(angle) * r}`);
            }

            const flake = Utils.svgEl('polygon', {
                points: points.join(' '),
                fill: document.body.classList.contains('theme-ink') ? 'none' : Utils.pick(['#c4903a', '#d4a04a', '#b48030', '#dab060']),
                stroke: document.body.classList.contains('theme-ink') ? '#5c3a1a' : 'none',
                'stroke-width': document.body.classList.contains('theme-ink') ? '1' : '0',
                opacity: '0.85'
            });
            g.appendChild(flake);

            g.setAttribute('transform', `translate(${x}, ${y}) rotate(${rotation})`);
            foodLayer.appendChild(g);
            food.el = g;
            foods.push(food);
        }
    }

    function update(dt) {
        for (let i = foods.length - 1; i >= 0; i--) {
            const f = foods[i];

            if (f.eaten) {
                if (f.el && f.el.parentNode) f.el.remove();
                foods.splice(i, 1);
                continue;
            }

            if (f.settled) continue;

            f.time += dt;

            // Fall with wobble
            f.y += f.fallSpeed * dt;
            f.x = f.startX + Math.sin(f.time * f.wobbleFreq) * f.wobbleAmp;
            f.rotation += dt * 60;

            // Settle on bottom
            const bottom = tankH - 70;
            if (f.y >= bottom) {
                f.y = bottom;
                f.settled = true;
                // Food decays after sitting too long
                setTimeout(() => { f.eaten = true; }, 15000);
            }

            if (f.el) {
                f.el.setAttribute('transform', `translate(${f.x}, ${f.y}) rotate(${f.rotation})`);
            }
        }
    }

    function getAll() { return foods; }

    function clear() {
        foods.forEach(f => { if (f.el && f.el.parentNode) f.el.remove(); });
        foods = [];
    }

    return { init, update, dropFood, getAll, clear, resize };
})();


/* ============================================
   ZENQUARIUM - Easter Egg Creatures
   ============================================ */

const Creatures = (() => {
    let creatures = [];
    let stingers = [];
    let inkClouds = [];
    let tankW = 0, tankH = 0;
    let layer = null;
    let spawnTimer = 0;
    let themeId = 'koi';
    const TAP_RESET_TIME = 5000; // reset tap count after 5s of no taps

    // Theme-appropriate creature definitions ‚Äî large, impressive visitors
    const creatureDefs = {
        koi: [
            { type: 'jellyfish', name: 'Moon Jelly', color: '#f0c8c8', color2: '#e8b0b0', accent: '#d08080', glow: 'rgba(240,200,200,0.18)', size: 2.2 },
            { type: 'squid', name: 'Firefly Squid', color: '#e8c060', color2: '#d0a840', accent: '#c08020', glow: 'rgba(232,192,96,0.15)', size: 1.8 },
            { type: 'octopus', name: 'Paper Octopus', color: '#c07848', color2: '#a06038', accent: '#e8a870', glow: 'rgba(192,120,72,0.15)', size: 2.0 },
        ],
        tropical: [
            { type: 'jellyfish', name: 'Blue Blubber', color: '#4090e0', color2: '#3070c0', accent: '#80c8ff', glow: 'rgba(64,144,224,0.22)', size: 2.4 },
            { type: 'octopus', name: 'Blue-Ring Octopus', color: '#d09040', color2: '#b07830', accent: '#4090ff', glow: 'rgba(64,144,255,0.18)', size: 2.0 },
        ],
        deep: [
            { type: 'jellyfish', name: 'Crystal Jelly', color: '#a060e0', color2: '#8040c0', accent: '#d0a0ff', glow: 'rgba(160,96,224,0.3)', size: 2.6 },
            { type: 'squid', name: 'Giant Squid', color: '#804020', color2: '#603018', accent: '#ff5050', glow: 'rgba(255,64,64,0.22)', size: 2.8 },
            { type: 'octopus', name: 'Dumbo Octopus', color: '#e08080', color2: '#c06060', accent: '#ff80b0', glow: 'rgba(255,96,160,0.22)', size: 2.2 },
        ],
        zen: [
            { type: 'jellyfish', name: 'Ghost Jelly', color: '#c0c0b8', color2: '#a8a8a0', accent: '#e0e0d8', glow: 'rgba(200,200,184,0.12)', size: 2.0 },
            { type: 'squid', name: 'Glass Squid', color: '#a0a090', color2: '#888878', accent: '#d0d0c0', glow: 'rgba(160,160,144,0.12)', size: 1.8 },
            { type: 'octopus', name: 'Stone Octopus', color: '#8a8878', color2: '#706860', accent: '#b0a898', glow: 'rgba(138,136,120,0.12)', size: 2.0 },
        ],
        ink: [
            { type: 'jellyfish', name: 'Ink Jelly', color: 'none', color2: 'none', accent: '#4a3a2a', glow: 'none', size: 2.2, ink: true },
            { type: 'octopus', name: 'Sketch Octopus', color: 'none', color2: 'none', accent: '#2a3a5a', glow: 'none', size: 2.0, ink: true },
        ]
    };

    function init(w, h, tid) {
        tankW = w; tankH = h;
        themeId = tid;
        layer = document.getElementById('fish-layer');
        creatures = [];
        spawnTimer = Utils.rand(30, 60); // first spawn after 30-60s
    }

    function createCreatureSVG(def) {
        const g = Utils.svgEl('g', { class: 'creature-group' });
        const s = def.size * 40;
        const pupils = []; // collect pupil elements for eye animation

        if (def.type === 'jellyfish') {
            // Soft outer glow
            if (def.glow !== 'none') {
                const glow = Utils.svgEl('ellipse', { cx: 0, cy: -s*0.05, rx: s*0.6, ry: s*0.55, fill: def.glow });
                g.appendChild(glow);
            }

            // Bell dome ‚Äî rounded mushroom shape
            const bell = Utils.svgEl('path', {
                d: `M ${-s*0.42} ${s*0.08} C ${-s*0.48} ${-s*0.3}, ${-s*0.35} ${-s*0.6}, 0 ${-s*0.62} C ${s*0.35} ${-s*0.6}, ${s*0.48} ${-s*0.3}, ${s*0.42} ${s*0.08} Q ${s*0.2} ${s*0.18}, 0 ${s*0.14} Q ${-s*0.2} ${s*0.18}, ${-s*0.42} ${s*0.08}Z`,
                fill: def.ink ? 'none' : def.color,
                stroke: def.ink ? def.accent : def.color2,
                'stroke-width': def.ink ? '1.5' : '0.8',
                opacity: def.ink ? '1' : '0.75'
            });
            g.appendChild(bell);

            // Interior radial pattern lines
            for (let r = 0; r < 4; r++) {
                const angle = (r / 4) * Math.PI * 0.6 - Math.PI * 0.3;
                const ix1 = Math.cos(angle) * s * 0.05;
                const iy1 = -s * 0.1;
                const ix2 = Math.cos(angle) * s * 0.3;
                const iy2 = -s * 0.4;
                const iline = Utils.svgEl('line', {
                    x1: ix1, y1: iy1, x2: ix2, y2: iy2,
                    stroke: def.ink ? def.accent : def.accent,
                    'stroke-width': '0.6',
                    opacity: '0.25',
                    'stroke-linecap': 'round'
                });
                g.appendChild(iline);
            }

            // Scalloped bell rim
            const rimCount = 8;
            for (let ri = 0; ri < rimCount; ri++) {
                const rx = (ri / (rimCount - 1) - 0.5) * s * 0.8;
                const scallop = Utils.svgEl('path', {
                    d: `M ${rx - s*0.05} ${s*0.1} Q ${rx} ${s*0.18}, ${rx + s*0.05} ${s*0.1}`,
                    fill: 'none',
                    stroke: def.ink ? def.accent : def.accent,
                    'stroke-width': def.ink ? '0.8' : '1',
                    opacity: '0.35',
                    'stroke-linecap': 'round'
                });
                g.appendChild(scallop);
            }

            // Oral arms (4 thick, ruffled)
            for (let oa = 0; oa < 4; oa++) {
                const ox = (oa - 1.5) * s * 0.12;
                const armLen = s * Utils.rand(0.55, 0.7);
                const ruffle = Utils.rand(6, 12);
                const arm = Utils.svgEl('path', {
                    d: `M ${ox} ${s*0.14} Q ${ox + ruffle} ${s*0.14 + armLen*0.3}, ${ox - ruffle*0.5} ${s*0.14 + armLen*0.6} Q ${ox + ruffle*0.7} ${s*0.14 + armLen*0.8}, ${ox + Utils.rand(-4,4)} ${s*0.14 + armLen}`,
                    fill: 'none',
                    stroke: def.ink ? def.accent : def.accent,
                    'stroke-width': def.ink ? '0.8' : Utils.rand(1.5, 2.5).toFixed(1),
                    'stroke-linecap': 'round',
                    opacity: Utils.rand(0.3, 0.5).toFixed(2),
                    class: 'tentacle'
                });
                g.appendChild(arm);
            }

            // Trailing tentacles (8 fine, long)
            for (let i = 0; i < 8; i++) {
                const tx = (i / 7 - 0.5) * s * 0.7;
                const tLen = s * Utils.rand(0.6, 1.0);
                const wave1 = Utils.rand(-10, 10);
                const wave2 = Utils.rand(-14, 14);
                const tentacle = Utils.svgEl('path', {
                    d: `M ${tx} ${s*0.15} Q ${tx + wave1} ${s*0.15 + tLen*0.35}, ${tx + wave2} ${s*0.15 + tLen*0.65} Q ${tx + wave1*0.5} ${s*0.15 + tLen*0.85}, ${tx + Utils.rand(-8,8)} ${s*0.15 + tLen}`,
                    fill: 'none',
                    stroke: def.ink ? def.accent : def.accent,
                    'stroke-width': def.ink ? '0.4' : Utils.rand(0.4, 0.9).toFixed(1),
                    'stroke-linecap': 'round',
                    opacity: Utils.rand(0.2, 0.4).toFixed(2),
                    class: 'tentacle'
                });
                g.appendChild(tentacle);
            }

        } else if (def.type === 'octopus') {
            // Soft glow
            if (def.glow !== 'none') {
                const glow = Utils.svgEl('ellipse', { cx: 0, cy: -s*0.1, rx: s*0.55, ry: s*0.55, fill: def.glow });
                g.appendChild(glow);
            }

            // Rounded mantle/head
            const head = Utils.svgEl('path', {
                d: `M ${-s*0.32} ${s*0.05} C ${-s*0.38} ${-s*0.15}, ${-s*0.35} ${-s*0.55}, 0 ${-s*0.58} C ${s*0.35} ${-s*0.55}, ${s*0.38} ${-s*0.15}, ${s*0.32} ${s*0.05} Q 0 ${s*0.12}, ${-s*0.32} ${s*0.05}Z`,
                fill: def.ink ? 'none' : def.color,
                stroke: def.ink ? def.accent : def.color2,
                'stroke-width': def.ink ? '1.5' : '0.8',
                opacity: def.ink ? '1' : '0.85'
            });
            g.appendChild(head);

            // Forehead texture spots
            for (let sp = 0; sp < 5; sp++) {
                const spx = Utils.rand(-s*0.2, s*0.2);
                const spy = Utils.rand(-s*0.5, -s*0.2);
                const spot = Utils.svgEl('circle', {
                    cx: spx, cy: spy, r: Utils.rand(1.5, 3.5),
                    fill: def.ink ? 'none' : def.color2,
                    stroke: def.ink ? def.accent : 'none',
                    'stroke-width': def.ink ? '0.4' : '0',
                    opacity: Utils.rand(0.15, 0.3).toFixed(2)
                });
                g.appendChild(spot);
            }

            // Eyes ‚Äî large, expressive
            [[-s*0.14, -s*0.15], [s*0.14, -s*0.15]].forEach(([ex, ey]) => {
                const eyeWhite = Utils.svgEl('ellipse', {
                    cx: ex, cy: ey, rx: s*0.08, ry: s*0.09,
                    fill: def.ink ? 'none' : '#f0f0e8',
                    stroke: def.ink ? def.accent : def.color2,
                    'stroke-width': def.ink ? '0.8' : '0.5'
                });
                g.appendChild(eyeWhite);
                const pupil = Utils.svgEl('ellipse', {
                    cx: ex, cy: ey + s*0.01, rx: s*0.035, ry: s*0.05,
                    fill: def.ink ? def.accent : '#1a1a1a'
                });
                g.appendChild(pupil);
                pupils.push({ el: pupil, baseCx: ex, maxShift: s * 0.04 });
                // Eye highlight
                if (!def.ink) {
                    const highlight = Utils.svgEl('circle', {
                        cx: ex - s*0.02, cy: ey - s*0.025, r: s*0.015,
                        fill: '#ffffff', opacity: '0.7'
                    });
                    g.appendChild(highlight);
                }
            });

            // 8 curling arms ‚Äî thick at base, tapering
            for (let i = 0; i < 8; i++) {
                const spread = (i / 7 - 0.5) * Math.PI * 0.85;
                const bx = Math.cos(spread) * s * 0.28;
                const by = s * 0.08;
                const curl = Utils.rand(0.6, 1.2) * (i % 2 === 0 ? 1 : -1);
                const armLen = s * Utils.rand(0.55, 0.75);
                const mx = bx + Math.cos(spread) * armLen * 0.5 + curl * 12;
                const my = by + armLen * 0.5;
                const ex = bx + Math.cos(spread) * armLen * 0.3 + curl * 18;
                const ey = by + armLen * 0.9 + Utils.rand(-5, 5);
                // Curl tip
                const tipX = ex + curl * 8;
                const tipY = ey + armLen * 0.15;
                const arm = Utils.svgEl('path', {
                    d: `M ${bx} ${by} Q ${mx} ${my}, ${ex} ${ey} Q ${(ex+tipX)/2} ${(ey+tipY)/2 + 3}, ${tipX} ${tipY}`,
                    fill: 'none',
                    stroke: def.ink ? def.accent : def.color,
                    'stroke-width': def.ink ? '0.8' : Utils.rand(2, 3.5).toFixed(1),
                    'stroke-linecap': 'round',
                    opacity: Utils.rand(0.55, 0.8).toFixed(2),
                    class: 'tentacle'
                });
                g.appendChild(arm);

                // Sucker dots along arm
                if (!def.ink) {
                    for (let si = 1; si <= 3; si++) {
                        const t = si / 4;
                        const sx = bx * (1-t) + ex * t + curl * 4 * t;
                        const sy = by * (1-t) + ey * t;
                        const sucker = Utils.svgEl('circle', {
                            cx: sx, cy: sy, r: Utils.rand(1, 2),
                            fill: def.color2, opacity: '0.3'
                        });
                        g.appendChild(sucker);
                    }
                }
            }

        } else if (def.type === 'squid') {
            // Soft glow
            if (def.glow !== 'none') {
                const glow = Utils.svgEl('ellipse', { cx: 0, cy: -s*0.05, rx: s*0.45, ry: s*0.6, fill: def.glow });
                g.appendChild(glow);
            }

            // Torpedo-shaped mantle
            const mantle = Utils.svgEl('path', {
                d: `M ${-s*0.22} ${s*0.15} C ${-s*0.26} ${-s*0.1}, ${-s*0.2} ${-s*0.45}, 0 ${-s*0.5} C ${s*0.2} ${-s*0.45}, ${s*0.26} ${-s*0.1}, ${s*0.22} ${s*0.15} Q 0 ${s*0.22}, ${-s*0.22} ${s*0.15}Z`,
                fill: def.ink ? 'none' : def.color,
                stroke: def.ink ? def.accent : def.color2,
                'stroke-width': def.ink ? '1.5' : '0.8',
                opacity: def.ink ? '1' : '0.85'
            });
            g.appendChild(mantle);

            // Side fins ‚Äî triangular, swept back
            const finL = Utils.svgEl('path', {
                d: `M ${-s*0.2} ${-s*0.2} Q ${-s*0.42} ${-s*0.35}, ${-s*0.35} ${-s*0.52} Q ${-s*0.22} ${-s*0.4}, ${-s*0.18} ${-s*0.28}`,
                fill: def.ink ? 'none' : def.color,
                stroke: def.ink ? def.accent : def.color2,
                'stroke-width': def.ink ? '0.8' : '0.5',
                opacity: '0.7'
            });
            g.appendChild(finL);
            const finR = Utils.svgEl('path', {
                d: `M ${s*0.2} ${-s*0.2} Q ${s*0.42} ${-s*0.35}, ${s*0.35} ${-s*0.52} Q ${s*0.22} ${-s*0.4}, ${s*0.18} ${-s*0.28}`,
                fill: def.ink ? 'none' : def.color,
                stroke: def.ink ? def.accent : def.color2,
                'stroke-width': def.ink ? '0.8' : '0.5',
                opacity: '0.7'
            });
            g.appendChild(finR);

            // Mantle stripe/pattern
            const stripe = Utils.svgEl('path', {
                d: `M 0 ${-s*0.45} L 0 ${s*0.12}`,
                stroke: def.ink ? def.accent : def.color2,
                'stroke-width': '0.5',
                opacity: '0.2'
            });
            g.appendChild(stripe);

            // Eyes ‚Äî large, round
            [[-s*0.1, -s*0.05], [s*0.1, -s*0.05]].forEach(([ex, ey]) => {
                const eyeOuter = Utils.svgEl('circle', {
                    cx: ex, cy: ey, r: s*0.06,
                    fill: def.ink ? 'none' : '#e8e8e0',
                    stroke: def.ink ? def.accent : def.color2,
                    'stroke-width': def.ink ? '0.8' : '0.5'
                });
                g.appendChild(eyeOuter);
                const eyeInner = Utils.svgEl('circle', {
                    cx: ex, cy: ey, r: s*0.03,
                    fill: def.ink ? def.accent : '#1a1a1a'
                });
                g.appendChild(eyeInner);
                pupils.push({ el: eyeInner, baseCx: ex, maxShift: s * 0.03 });
            });

            // 8 short arms
            for (let i = 0; i < 8; i++) {
                const spread = (i / 7 - 0.5) * s * 0.38;
                const armLen = s * Utils.rand(0.3, 0.45);
                const wave = Utils.rand(-8, 8);
                const arm = Utils.svgEl('path', {
                    d: `M ${spread} ${s*0.18} Q ${spread + wave} ${s*0.18 + armLen*0.5}, ${spread + wave*0.5} ${s*0.18 + armLen}`,
                    fill: 'none',
                    stroke: def.ink ? def.accent : def.color,
                    'stroke-width': def.ink ? '0.6' : Utils.rand(1.2, 2).toFixed(1),
                    'stroke-linecap': 'round',
                    opacity: Utils.rand(0.4, 0.65).toFixed(2),
                    class: 'tentacle'
                });
                g.appendChild(arm);
            }

            // 2 long feeding tentacles with club tips
            for (let lt = 0; lt < 2; lt++) {
                const lx = (lt - 0.5) * s * 0.15;
                const longLen = s * Utils.rand(0.8, 1.1);
                const wave1 = Utils.rand(-12, 12);
                const wave2 = Utils.rand(-8, 8);
                const tentacle = Utils.svgEl('path', {
                    d: `M ${lx} ${s*0.18} Q ${lx + wave1} ${s*0.18 + longLen*0.4}, ${lx + wave2} ${s*0.18 + longLen*0.7} Q ${lx + wave1*0.3} ${s*0.18 + longLen*0.9}, ${lx + Utils.rand(-5,5)} ${s*0.18 + longLen}`,
                    fill: 'none',
                    stroke: def.ink ? def.accent : def.color,
                    'stroke-width': def.ink ? '0.5' : '1',
                    'stroke-linecap': 'round',
                    opacity: '0.5',
                    class: 'tentacle'
                });
                g.appendChild(tentacle);
                // Club tip
                const tipY = s*0.18 + longLen;
                const tipX = lx + Utils.rand(-5, 5);
                const club = Utils.svgEl('ellipse', {
                    cx: tipX, cy: tipY, rx: s*0.03, ry: s*0.06,
                    fill: def.ink ? 'none' : def.accent,
                    stroke: def.ink ? def.accent : 'none',
                    'stroke-width': def.ink ? '0.5' : '0',
                    opacity: '0.45'
                });
                g.appendChild(club);
            }
        }

        return { el: g, pupils: pupils };
    }

    function spawn() {
        const defs = creatureDefs[themeId] || creatureDefs.koi;
        const def = Utils.pick(defs);

        const creature = {
            def: def,
            x: -150,
            y: Utils.rand(tankH * 0.15, tankH * 0.55),
            speed: Utils.rand(0.25, 0.5),
            bobPhase: Math.random() * Math.PI * 2,
            bobSpeed: Utils.rand(1.2, 2.0),
            bobAmp: Utils.rand(10, 25),
            pulsePhase: 0,
            el: null,
            tapCount: 0,
            lastTapTime: 0,
            fleeing: false,
            fleeTimer: 0,
            normalSpeed: 0,
            provoked: false,
            eatCooldown: 0,
            fishEaten: 0,
            hunting: false,
            huntTarget: null,
            lungeScale: 0
        };

        // Swim direction: left-to-right or right-to-left
        if (Math.random() < 0.5) {
            creature.x = tankW + 150;
            creature.speed = -creature.speed;
        }
        creature.normalSpeed = creature.speed;

        const result = createCreatureSVG(def);
        creature.el = result.el;
        creature.pupils = result.pupils;
        creature.gazePhase = Math.random() * Math.PI * 2;
        layer.appendChild(creature.el);
        creatures.push(creature);
        if (typeof Achievements !== 'undefined') Achievements.onCreatureSpawn(def.type);
        // Warn the player
        const icons = { jellyfish: 'ü™º', octopus: 'üêô', squid: 'ü¶ë' };
        const icon = icons[def.type] || 'ü¶ë';
        if (typeof UI !== 'undefined' && UI.showStatus) {
            UI.showStatus(`‚ö†Ô∏è ${icon} ${def.name} spotted! Tap to chase it away!`);
        }
    }

    // --- Stinger system (jellyfish 3rd tap) ---
    function dropStingers(creature) {
        const s = creature.def.size * 40;
        const bobY = Math.sin(creature.bobPhase) * creature.bobAmp;
        const cx = creature.x;
        const cy = creature.y + bobY + s * 0.2;
        const count = Utils.randInt(5, 8);
        const isInk = creature.def.ink;

        for (let i = 0; i < count; i++) {
            const stinger = {
                x: cx + Utils.rand(-s * 0.7, s * 0.7),
                y: cy + Utils.rand(-s * 0.1, s * 0.4),
                vx: Utils.rand(-25, 25),
                vy: Utils.rand(6, 20),
                rotation: Utils.rand(0, 360),
                time: 0,
                maxLife: Utils.rand(12, 15),
                el: null
            };

            const g = Utils.svgEl('g', { class: 'stinger-group' });
            // Barbed stinger shape
            const stingerLen = Utils.rand(8, 14);
            const path = Utils.svgEl('path', {
                d: `M 0 0 L ${Utils.rand(-2, 2)} ${stingerLen} M 0 ${stingerLen * 0.3} L ${-3} ${stingerLen * 0.15} M 0 ${stingerLen * 0.5} L ${3} ${stingerLen * 0.35} M 0 ${stingerLen * 0.7} L ${-2.5} ${stingerLen * 0.55}`,
                stroke: isInk ? creature.def.accent : Utils.pick(['#e060a0', '#d050c0', '#c040a0', '#e08080']),
                'stroke-width': isInk ? '0.8' : '1.2',
                'stroke-linecap': 'round',
                fill: 'none',
                opacity: '0.8'
            });
            g.appendChild(path);
            // Small venom droplet at tip
            if (!isInk) {
                const drop = Utils.svgEl('circle', {
                    cx: 0, cy: stingerLen + 2, r: 1.5,
                    fill: Utils.pick(['#e060a0', '#ff80c0']),
                    opacity: '0.6'
                });
                g.appendChild(drop);
            }

            g.setAttribute('transform', `translate(${stinger.x}, ${stinger.y}) rotate(${stinger.rotation})`);
            layer.appendChild(g);
            stinger.el = g;
            stingers.push(stinger);
        }
    }

    // --- Ink cloud system (octopus/squid 3rd tap) ---
    function squirtInk(creature) {
        const s = creature.def.size * 40;
        const bobY = Math.sin(creature.bobPhase) * creature.bobAmp;
        const isOctopus = creature.def.type === 'octopus';
        const isInk = creature.def.ink;

        // Ink squirts behind the creature (opposite of flee direction)
        const inkX = creature.x + (creature.speed > 0 ? -s * 0.3 : s * 0.3);
        const inkY = creature.y + bobY;

        // Main ink cloud
        const cloud = {
            x: inkX,
            y: inkY,
            vx: Utils.rand(-8, 8),
            vy: Utils.rand(-4, 6),
            time: 0,
            maxLife: 10,
            maxRadius: s * Utils.rand(1.8, 2.7),
            el: null,
            blobs: [] // individual blob elements with independent drift
        };

        const g = Utils.svgEl('g', { class: 'ink-cloud' });

        if (isInk) {
            // Ink theme: stroke-only splatter
            const splatCount = Utils.randInt(5, 8);
            for (let i = 0; i < splatCount; i++) {
                const dx = Utils.rand(-20, 20);
                const dy = Utils.rand(-20, 20);
                const r = Utils.rand(6, 18);
                const splat = Utils.svgEl('circle', {
                    cx: dx, cy: dy, r: r,
                    fill: 'none',
                    stroke: creature.def.accent,
                    'stroke-width': '1',
                    opacity: '0.6'
                });
                g.appendChild(splat);
                cloud.blobs.push({ el: splat, ox: dx, oy: dy, vx: Utils.rand(-15, 15), vy: Utils.rand(-10, 10) });
            }
        } else {
            // 3 overlapping blobs for organic cloud shape
            const inkColor = isOctopus ? 'rgba(10, 15, 40, 0.7)' : 'rgba(30, 180, 80, 0.55)';
            const glowColor = isOctopus ? 'rgba(20, 30, 60, 0.3)' : 'rgba(50, 255, 100, 0.25)';
            // Outer glow (added first so it's behind)
            const glow = Utils.svgEl('ellipse', {
                cx: 0, cy: 0, rx: 52, ry: 42,
                fill: glowColor
            });
            g.appendChild(glow);
            cloud.blobs.push({ el: glow, ox: 0, oy: 0, vx: Utils.rand(-5, 5), vy: Utils.rand(-3, 3) });
            for (let i = 0; i < 3; i++) {
                const dx = Utils.rand(-18, 18);
                const dy = Utils.rand(-15, 15);
                const rx = Utils.rand(22, 45);
                const ry = Utils.rand(18, 38);
                const blob = Utils.svgEl('ellipse', {
                    cx: dx, cy: dy, rx: rx, ry: ry,
                    fill: inkColor
                });
                g.appendChild(blob);
                cloud.blobs.push({ el: blob, ox: dx, oy: dy, vx: Utils.rand(-18, 18), vy: Utils.rand(-12, 12) });
            }
        }

        g.setAttribute('transform', `translate(${cloud.x}, ${cloud.y}) scale(0.3)`);
        g.style.opacity = '1';
        layer.appendChild(g);
        cloud.el = g;
        inkClouds.push(cloud);
    }

    // --- Handle tap near creature ---
    function handleTap(clickX, clickY, state) {
        const now = performance.now();
        let tappedCreature = null;

        for (const c of creatures) {
            const s = c.def.size * 40;
            const bobY = Math.sin(c.bobPhase) * c.bobAmp;
            const dist = Utils.dist(clickX, clickY, c.x, c.y + bobY);
            const hitRadius = s * 1.5;
            if (dist < hitRadius) {
                tappedCreature = c;
                break;
            }
        }

        if (!tappedCreature) return false;

        const c = tappedCreature;

        // Reset tap count if too long since last tap
        if (now - c.lastTapTime > TAP_RESET_TIME) {
            c.tapCount = 0;
        }
        c.tapCount++;
        c.lastTapTime = now;

        if (c.tapCount < 3) {
            // Taps 1-2: creature flees in a random direction
            if (!c.fleeing) c.normalSpeed = c.speed;
            c.speed = (Math.random() < 0.5 ? 1 : -1) * Math.abs(c.normalSpeed) * Utils.rand(3, 4.5);
            c.y += Utils.rand(-60, 60); // jolt vertically
            c.y = Utils.clamp(c.y, tankH * 0.1, tankH * 0.6);
            c.fleeing = true;
            c.fleeTimer = Utils.rand(2, 3);
            ZenAudio.playTapGlass(0.5);
            return 'flee';
        }

        // 3rd tap ‚Äî special reaction!
        c.tapCount = 0;
        c.provoked = true;

        if (c.def.type === 'jellyfish') {
            dropStingers(c);
            ZenAudio.playStingerRelease();
            // Jellyfish bolts away
            c.speed = (Math.random() < 0.5 ? 1 : -1) * Math.abs(c.normalSpeed || c.speed) * 5;
            c.fleeing = true;
            c.fleeTimer = 3;
            return 'stingers';
        } else {
            // Octopus or squid
            squirtInk(c);
            ZenAudio.playInkSquirt();
            // Health penalty
            state.tankHealth = Math.max(0, state.tankHealth - Utils.rand(15, 20));
            // Creature bolts away
            c.speed = (Math.random() < 0.5 ? 1 : -1) * Math.abs(c.normalSpeed || c.speed) * 5;
            c.fleeing = true;
            c.fleeTimer = 3;
            return c.def.type === 'octopus' ? 'octopus-ink' : 'squid-ink';
        }
    }

    function update(dt, allFish) {
        const eatenByCreature = [];

        // Spawn timer
        spawnTimer -= dt;
        if (spawnTimer <= 0) {
            spawnTimer = Utils.rand(45, 90); // spawn every 45-90 seconds
            if (creatures.length < 1) spawn();
        }

        // Update existing creatures
        for (let i = creatures.length - 1; i >= 0; i--) {
            const c = creatures[i];

            // Move across tank
            c.x += c.speed * 60 * dt;
            c.bobPhase += c.bobSpeed * dt;
            const bobY = Math.sin(c.bobPhase) * c.bobAmp;

            // Flee timer ‚Äî return to normal speed after fleeing
            if (c.fleeing) {
                c.fleeTimer -= dt;
                if (c.fleeTimer <= 0) {
                    c.fleeing = false;
                    c.speed = c.normalSpeed;
                    c.hunting = false;
                    c.huntTarget = null;
                }
            }

            // Creature must be fully on-screen before hunting or eating
            const fullyOnScreen = c.x > 50 && c.x < tankW - 50;

            // Octopus/squid active hunting ‚Äî lunge toward nearby fish
            const isHunter = c.def.type === 'octopus' || c.def.type === 'squid';
            if (isHunter && !c.fleeing && c.eatCooldown <= 0 && fullyOnScreen) {
                let nearest = null, nearDist = Infinity;
                for (const fish of allFish) {
                    if (!fish.alive) continue;
                    const d = Utils.dist(fish.x, fish.y, c.x, c.y + bobY);
                    if (d < 200 && d < nearDist) {
                        nearDist = d;
                        nearest = fish;
                    }
                }
                if (nearest) {
                    c.hunting = true;
                    c.huntTarget = nearest;
                    // Lunge toward prey
                    const angle = Math.atan2(nearest.y - (c.y + bobY), nearest.x - c.x);
                    const lungeSpeed = 1.8;
                    c.x += Math.cos(angle) * lungeSpeed * 60 * dt;
                    c.y += Math.sin(angle) * lungeSpeed * 60 * dt;
                } else {
                    c.hunting = false;
                    c.huntTarget = null;
                }
            }

            // Jellyfish pulsing animation
            c.pulsePhase += dt * 2;
            const pulse = c.def.type === 'jellyfish' ? 1 + Math.sin(c.pulsePhase) * 0.06 : 1;

            // Lunge scale animation (octopus/squid pounce on eat)
            let lungeAnim = 1;
            if (c.lungeScale > 0) {
                c.lungeScale = Math.max(0, c.lungeScale - dt * 3);
                lungeAnim = 1 + c.lungeScale * 0.3;
            }

            const scaleX = c.speed > 0 ? 1 : -1;
            c.el.setAttribute('transform',
                `translate(${c.x}, ${c.y + bobY}) scale(${scaleX * pulse * lungeAnim}, ${pulse * lungeAnim})`
            );

            // Animate eyes ‚Äî octopus/squid track prey when hunting, idle gaze otherwise
            if (c.pupils && c.pupils.length > 0) {
                if (c.hunting && c.huntTarget && c.huntTarget.alive) {
                    // Lock pupils on prey
                    const preyDir = c.huntTarget.x > c.x ? 1 : -1;
                    const gazeDir = preyDir * scaleX;
                    for (const p of c.pupils) {
                        p.el.setAttribute('cx', p.baseCx + gazeDir * p.maxShift * 0.8);
                    }
                } else {
                    c.gazePhase += dt * 0.8;
                    const rawGaze = Math.sin(c.gazePhase);
                    const gaze = Math.abs(rawGaze) < 0.3 ? 0 : rawGaze;
                    for (const p of c.pupils) {
                        p.el.setAttribute('cx', p.baseCx + gaze * p.maxShift);
                    }
                }
            }

            // Eat cooldown
            if (c.eatCooldown > 0) c.eatCooldown -= dt;

            // Scare nearby fish ‚Äî fish flee from large creatures
            // Eat fish on close contact (kill radius varies by type, with cooldown)
            const killRadius = c.def.type === 'jellyfish' ? 45 : 40;
            for (const fish of allFish) {
                if (!fish.alive) continue;
                const dist = Utils.dist(fish.x, fish.y, c.x, c.y + bobY);
                if (dist < killRadius && c.eatCooldown <= 0 && !c.fleeing && fullyOnScreen) {
                    fish.alive = false;
                    c.eatCooldown = 8;
                    c.fishEaten++;
                    if (isHunter) c.lungeScale = 1;
                    eatenByCreature.push({ fish, creature: c });
                } else if (dist < 250) {
                    const fleeAngle = Math.atan2(fish.y - (c.y + bobY), fish.x - c.x);
                    fish.targetX = Utils.clamp(fish.x + Math.cos(fleeAngle) * 280, 60, fish.tankW - 60);
                    fish.targetY = Utils.clamp(fish.y + Math.sin(fleeAngle) * 160, 60, fish.tankH - 100);
                    fish.speed = fish.baseSpeed * 4;
                    fish.dartCooldown = Math.max(fish.dartCooldown, 0.8);
                }
            }

            // Remove when off-screen
            if ((c.speed > 0 && c.x > tankW + 180) || (c.speed < 0 && c.x < -180)) {
                if (c.el.parentNode) c.el.remove();
                if (typeof Achievements !== 'undefined') Achievements.onCreatureExit(c);
                creatures.splice(i, 1);
            }
        }

        // Update stingers ‚Äî drift, collision detection, fade
        for (let i = stingers.length - 1; i >= 0; i--) {
            const st = stingers[i];
            st.time += dt;

            if (st.time >= st.maxLife) {
                if (st.el && st.el.parentNode) st.el.remove();
                stingers.splice(i, 1);
                continue;
            }

            // Drift downward with slight horizontal sway
            st.x += st.vx * dt;
            st.y += st.vy * dt;
            st.vx *= 0.98; // slow horizontal drift
            st.rotation += dt * 20;

            // Fade out in last 2 seconds
            const opacity = st.time > st.maxLife - 2 ? Math.max(0, (st.maxLife - st.time) / 2) * 0.8 : 0.8;
            if (st.el) {
                st.el.setAttribute('transform', `translate(${st.x}, ${st.y}) rotate(${st.rotation})`);
                st.el.style.opacity = opacity;
            }

            // Collision with fish ‚Äî kill on contact
            for (const fish of allFish) {
                if (!fish.alive) continue;
                const dist = Utils.dist(fish.x, fish.y, st.x, st.y);
                if (dist < fish.size * 25 + 10) {
                    fish.health = 0;
                    fish.alive = false;
                    // Remove stinger on hit
                    if (st.el && st.el.parentNode) st.el.remove();
                    stingers.splice(i, 1);
                    break;
                }
            }
        }

        // Update ink clouds ‚Äî expand, drift, fade, and kill fish on contact
        for (let i = inkClouds.length - 1; i >= 0; i--) {
            const cloud = inkClouds[i];
            cloud.time += dt;

            if (cloud.time >= cloud.maxLife) {
                if (cloud.el && cloud.el.parentNode) cloud.el.remove();
                inkClouds.splice(i, 1);
                continue;
            }

            // Drift movement (whole cloud)
            cloud.x += cloud.vx * dt;
            cloud.y += cloud.vy * dt;
            cloud.vx *= 0.995;
            cloud.vy *= 0.995;

            // Expand quickly then slow, fade out
            const expandT = Math.min(cloud.time / 1.5, 1);
            const scale = 0.3 + Utils.easeOutCubic(expandT) * 1.8;
            const fadeT = cloud.time / cloud.maxLife;
            const opacity = fadeT < 0.3 ? 1 : Math.max(0, 1 - (fadeT - 0.3) / 0.7);

            // Drift individual blobs outward for dispersal effect
            for (const blob of cloud.blobs) {
                blob.ox += blob.vx * dt;
                blob.oy += blob.vy * dt;
                blob.vx *= 0.99;
                blob.vy *= 0.99;
                if (blob.el.tagName === 'ellipse') {
                    blob.el.setAttribute('cx', blob.ox);
                    blob.el.setAttribute('cy', blob.oy);
                } else {
                    blob.el.setAttribute('cx', blob.ox);
                    blob.el.setAttribute('cy', blob.oy);
                }
            }

            if (cloud.el) {
                cloud.el.setAttribute('transform', `translate(${cloud.x}, ${cloud.y}) scale(${scale})`);
                cloud.el.style.opacity = opacity;
            }

            // Kill fish that touch the ink cloud (while still visible)
            if (opacity > 0.15) {
                const hitRadius = cloud.maxRadius * scale * 0.4;
                for (const fish of allFish) {
                    if (!fish.alive) continue;
                    const dist = Utils.dist(fish.x, fish.y, cloud.x, cloud.y);
                    if (dist < hitRadius) {
                        fish.health = 0;
                        fish.alive = false;
                    }
                }
            }
        }

        return eatenByCreature;
    }

    function clear() {
        creatures.forEach(c => { if (c.el && c.el.parentNode) c.el.remove(); });
        creatures = [];
        stingers.forEach(s => { if (s.el && s.el.parentNode) s.el.remove(); });
        stingers = [];
        inkClouds.forEach(c => { if (c.el && c.el.parentNode) c.el.remove(); });
        inkClouds = [];
        spawnTimer = Utils.rand(30, 60);
    }

    function resize(w, h) {
        tankW = w; tankH = h;
    }

    return { init, update, clear, resize, handleTap };
})();


/* ============================================
   ZENQUARIUM - Achievements System
   ============================================ */

const Achievements = (() => {
    const defs = [
        { id: 'first-fish',       icon: 'üêü', name: 'First Fish',       desc: 'Buy your first fish' },
        { id: 'full-spectrum',    icon: 'üåà', name: 'Full Spectrum',    desc: 'Own all 4 species of a theme at once' },
        { id: 'schooling',       icon: 'üéì', name: "School's In",      desc: 'Have 3+ of the same species schooling' },
        { id: 'baby-boom',       icon: 'üçº', name: 'Baby Boom',        desc: 'Have 3 babies born in one session' },
        { id: 'survivor',        icon: 'üíÄ', name: 'Survivor',         desc: 'Recover tank health from below 20% to above 80%' },
        { id: 'creature-encounter', icon: 'ü¶ë', name: 'Creature Encounter', desc: 'See your first Easter egg creature' },
        { id: 'glass-tapper',    icon: 'üëÜ', name: 'Glass Tapper',     desc: 'Tap the glass 10 times in one session' },
        { id: 'stinger-dodge',   icon: 'ü™º', name: 'Stinger Dodge',    desc: 'Survive a jellyfish stinger attack with no fish deaths' },
        { id: 'ink-survivor',    icon: 'üõ°Ô∏è', name: 'Ink Survivor',     desc: 'Have fish survive an ink cloud' },
        { id: 'thousandaire',    icon: 'üí∞', name: 'Thousandaire',     desc: 'Reach a score of 1,000' },
        { id: 'ten-thousandaire', icon: 'üíé', name: 'Ten Thousandaire', desc: 'Reach a score of 10,000' },
        { id: 'zen-master',      icon: 'üèÜ', name: 'Zen Master',       desc: 'Play all 5 themes' },
        { id: 'pacifist',        icon: '‚òÆÔ∏è', name: 'Pacifist',         desc: 'Complete a session with zero fish deaths' },
        { id: 'speed-run',      icon: '‚ö°', name: 'Speed Run',        desc: 'Reach 1,000 points in under 3 minutes' },
        { id: 'fish-whisperer', icon: 'üê†', name: 'Fish Whisperer',  desc: 'Have 15+ fish alive at once' },
        { id: 'night-owl',      icon: 'üåô', name: 'Night Owl',        desc: 'Play for 10+ minutes in a session' },
        { id: 'streak-master',  icon: 'üî•', name: 'Streak Master',    desc: 'Reach a √ó3 score multiplier' },
        { id: 'creature-collector', icon: 'üß¨', name: 'Creature Collector', desc: 'See all 3 creature types in one session' },
        { id: 'danger-zone',   icon: '‚ö†Ô∏è', name: 'Danger Zone',      desc: 'Survive 3 creature attacks in one session' },
        { id: 'high-roller',   icon: 'üé∞', name: 'High Roller',      desc: 'Reach a score of 5,000 in a single session' },
    ];

    // Session-local tracking
    let sessionData = {};

    function resetSession() {
        sessionData = {
            fishBorn: 0,
            fishLost: 0,
            tapCount: 0,
            peakFishCount: 0,
            sawCreature: false,
            tankWasBelow20: false,
            stingerActiveNoDeaths: false,
            stingerCheckActive: false,
            inkCloudActiveNoDeaths: false,
            inkCloudCheckActive: false,
            creatureTypesSeen: new Set(),
            attacksSurvived: 0,
            startTime: performance.now(),
            newAchievements: []
        };
    }

    const achievementBonuses = {
        'first-fish': 25, 'full-spectrum': 100, 'schooling': 50,
        'baby-boom': 75, 'survivor': 150, 'creature-encounter': 50,
        'glass-tapper': 25, 'stinger-dodge': 75, 'ink-survivor': 75,
        'thousandaire': 50, 'ten-thousandaire': 100, 'zen-master': 500,
        'pacifist': 200, 'speed-run': 100, 'fish-whisperer': 100,
        'night-owl': 50, 'streak-master': 250,
        'creature-collector': 200, 'danger-zone': 150,
        'high-roller': 150
    };

    function tryUnlock(id) {
        if (ZenStorage.unlockAchievement(id)) {
            sessionData.newAchievements.push(id);
            showToast(id);
            const bonus = achievementBonuses[id] || 0;
            if (bonus > 0 && typeof App !== 'undefined' && App.scoreEvent) {
                const def = defs.find(d => d.id === id);
                App.scoreEvent(bonus, `üèÜ ${def ? def.name : id}! +${bonus}`);
            }
            return true;
        }
        return false;
    }

    function showToast(id) {
        const def = defs.find(d => d.id === id);
        if (!def) return;
        const toast = document.getElementById('achievement-toast');
        const icon = document.getElementById('toast-icon');
        const name = document.getElementById('toast-name');
        if (!toast) return;
        icon.textContent = def.icon;
        name.textContent = def.name;
        toast.classList.add('show');
        setTimeout(() => toast.classList.remove('show'), 3500);
    }

    // Called from game loop each frame
    function check(state) {
        const score = Math.round(state.score);
        const aliveFish = state.fish.filter(f => f.alive);
        const fishCount = aliveFish.length;

        // Track peak fish
        if (fishCount > sessionData.peakFishCount) {
            sessionData.peakFishCount = fishCount;
            ZenStorage.setStatMax('highestFishCount', fishCount);
        }

        // First fish
        if (fishCount > 0) tryUnlock('first-fish');

        // Score milestones
        if (score >= 1000) tryUnlock('thousandaire');
        if (score >= 5000) tryUnlock('high-roller');
        if (score >= 10000) tryUnlock('ten-thousandaire');

        // Full spectrum ‚Äî all 4 types present
        if (state.theme && state.theme.fishTypes) {
            const typeIds = state.theme.fishTypes.map(t => t.id);
            const presentTypes = new Set(aliveFish.map(f => f.type));
            if (typeIds.length > 0 && typeIds.every(id => presentTypes.has(id))) {
                tryUnlock('full-spectrum');
            }
        }

        // Schooling ‚Äî 3+ same type nearby
        const typeCounts = {};
        aliveFish.forEach(f => { typeCounts[f.type] = (typeCounts[f.type] || 0) + 1; });
        if (Object.values(typeCounts).some(c => c >= 3)) tryUnlock('schooling');

        // Survivor ‚Äî tank was below 20 and is now above 80
        if (state.tankHealth < 20) sessionData.tankWasBelow20 = true;
        if (sessionData.tankWasBelow20 && state.tankHealth > 80) {
            tryUnlock('survivor');
            sessionData.tankWasBelow20 = false;
        }

        // Zen Master ‚Äî play all 5 themes
        const played = ZenStorage.get().themesPlayed;
        if (played && played.length >= 5) {
            tryUnlock('zen-master');
        }

        // Fish Whisperer ‚Äî 15+ fish alive
        if (fishCount >= 15) tryUnlock('fish-whisperer');

        // Speed Run ‚Äî 1000 points in under 3 minutes
        const sessionSec = (performance.now() - sessionData.startTime) / 1000;
        if (score >= 1000 && sessionSec < 180) tryUnlock('speed-run');

        // Night Owl ‚Äî 10+ minutes session
        if (sessionSec >= 600) tryUnlock('night-owl');

        // Streak Master ‚Äî √ó3 multiplier
        if (state.multiplier >= 3) tryUnlock('streak-master');
    }

    // Called from specific events
    function onFishBorn() {
        sessionData.fishBorn++;
        ZenStorage.addStat('totalFishBorn');
        if (sessionData.fishBorn >= 3) tryUnlock('baby-boom');
    }

    function onFishLost() {
        sessionData.fishLost++;
        ZenStorage.addStat('totalFishLost');
        // Check stinger dodge failure
        if (sessionData.stingerCheckActive) sessionData.stingerActiveNoDeaths = false;
        if (sessionData.inkCloudCheckActive) sessionData.inkCloudActiveNoDeaths = false;
    }

    function onCreatureSpawn(creatureType) {
        sessionData.sawCreature = true;
        ZenStorage.addStat('creaturesEncountered');
        tryUnlock('creature-encounter');
        if (typeof App !== 'undefined' && App.scoreEvent) {
            App.scoreEvent(15, 'ü¶ë Creature sighting! +15');
        }
        if (creatureType) {
            sessionData.creatureTypesSeen.add(creatureType);
            if (sessionData.creatureTypesSeen.size >= 3) tryUnlock('creature-collector');
        }
    }

    function onGlassTap() {
        sessionData.tapCount++;
        if (sessionData.tapCount >= 10) tryUnlock('glass-tapper');
    }

    function onStingersReleased(fishCountBefore) {
        sessionData.stingerCheckActive = true;
        sessionData.stingerActiveNoDeaths = true;
        if (typeof App !== 'undefined' && App.scoreEvent) {
            App.scoreEvent(-25, 'ü™º Provoked stingers! -25');
        }
        // Check after stingers expire
        setTimeout(() => {
            if (sessionData.stingerActiveNoDeaths) {
                tryUnlock('stinger-dodge');
                sessionData.attacksSurvived++;
                if (sessionData.attacksSurvived >= 3) tryUnlock('danger-zone');
                if (typeof App !== 'undefined' && App.scoreEvent) {
                    App.scoreEvent(50, 'üõ°Ô∏è Stinger survivor! +50');
                }
            }
            sessionData.stingerCheckActive = false;
        }, 16000);
    }

    function onInkSquirted(fishCountBefore) {
        sessionData.inkCloudCheckActive = true;
        sessionData.inkCloudActiveNoDeaths = true;
        if (typeof App !== 'undefined' && App.scoreEvent) {
            App.scoreEvent(-20, 'üêô Provoked ink! -20');
        }
        setTimeout(() => {
            if (sessionData.inkCloudActiveNoDeaths) {
                tryUnlock('ink-survivor');
                sessionData.attacksSurvived++;
                if (sessionData.attacksSurvived >= 3) tryUnlock('danger-zone');
                if (typeof App !== 'undefined' && App.scoreEvent) {
                    App.scoreEvent(40, 'üõ°Ô∏è Ink cloud survivor! +40');
                }
            }
            sessionData.inkCloudCheckActive = false;
        }, 11000);
    }

    function onFoodDropped(count) {
        ZenStorage.addStat('totalFoodDropped', count);
    }

    function onClean() {
        ZenStorage.addStat('totalCleans');
    }

    function onCreatureExit(creature) {
        if (creature.fishEaten === 0) {
            if (typeof App !== 'undefined' && App.scoreEvent) {
                App.scoreEvent(30, 'üïäÔ∏è Creature whisperer! +30');
            }
        }
    }

    function getSessionData() { return sessionData; }
    function getDefs() { return defs; }

    function getSessionDuration() {
        return (performance.now() - sessionData.startTime) / 1000;
    }

    function onSessionEnd() {
        const duration = getSessionDuration();
        // Pacifist ‚Äî zero fish deaths in a session lasting 2+ minutes
        if (sessionData.fishLost === 0 && duration >= 120) {
            tryUnlock('pacifist');
        }
    }

    return {
        defs: defs, getDefs, resetSession, check, getSessionData, getSessionDuration, onSessionEnd,
        onFishBorn, onFishLost, onCreatureSpawn, onCreatureExit, onGlassTap,
        onStingersReleased, onInkSquirted, onFoodDropped, onClean
    };
})();


/* ============================================
   ZENQUARIUM - UI System
   ============================================ */

const UI = (() => {
    let statusQueue = [];
    let statusTimer = null;
    let fishDetailVisible = false;

    function init() {
        // Fish count click to toggle detail
        const fishCountEl = document.getElementById('fish-count-display');
        if (fishCountEl) {
            fishCountEl.style.cursor = 'pointer';
            fishCountEl.addEventListener('click', toggleFishDetail);
        }
        // Score display click to toggle multiplier detail
        const scoreEl = document.getElementById('score-display');
        if (scoreEl) {
            scoreEl.style.cursor = 'pointer';
            scoreEl.addEventListener('click', () => {
                const appState = App.getState();
                toggleMultiplierPanel(appState.multiplier, appState.streakActive, appState.streakStart);
            });
        }
    }

    function updateScore(value) {
        const el = document.getElementById('score-value');
        if (el) el.textContent = Utils.formatNum(value);
    }

    function updateHealth(health) {
        const fill = document.getElementById('health-fill');
        if (!fill) return;
        fill.style.width = health + '%';
        fill.className = 'health-fill';
        if (health < 30) fill.classList.add('danger');
        else if (health < 60) fill.classList.add('warning');
    }

    function updateFishCount(count, max) {
        const el = document.getElementById('fish-count-value');
        if (el) el.textContent = `${count}/${max}`;
    }

    function updateFishDetail(fishByType) {
        const list = document.getElementById('fish-detail-list');
        if (!list) return;
        list.innerHTML = '';
        for (const [typeName, info] of Object.entries(fishByType)) {
            const row = Utils.htmlEl('div', 'fish-detail-row');
            const colorDot = Utils.htmlEl('span', 'fish-type-color');
            colorDot.style.backgroundColor = info.color;
            const nameSpan = Utils.htmlEl('span', '', typeName);
            const countSpan = Utils.htmlEl('span', '', `√ó${info.count}`);
            row.appendChild(colorDot);
            row.appendChild(nameSpan);
            row.appendChild(countSpan);
            list.appendChild(row);
        }
    }

    function toggleFishDetail() {
        const panel = document.getElementById('fish-detail-panel');
        const backdrop = document.getElementById('flyout-backdrop');
        fishDetailVisible = !fishDetailVisible;
        panel.classList.toggle('hidden', !fishDetailVisible);
        if (fishDetailVisible) {
            multiplierPanelVisible = false;
            document.getElementById('multiplier-panel').classList.add('hidden');
            backdrop.classList.add('active');
        } else {
            backdrop.classList.remove('active');
        }
    }

    let multiplierPanelVisible = false;

    function updateMultiplier(value) {
        const badge = document.getElementById('multiplier-badge');
        if (!badge) return;
        badge.textContent = value > 1 ? `√ó${value}` : '√ó1';
        badge.className = 'multiplier-badge';
        if (value >= 3) badge.classList.add('max');
        else if (value >= 2) badge.classList.add('high');
        else if (value > 1) badge.classList.add('active');
    }

    function toggleMultiplierPanel(multiplier, streakActive, streakStart) {
        const panel = document.getElementById('multiplier-panel');
        const detail = document.getElementById('multiplier-detail');
        const backdrop = document.getElementById('flyout-backdrop');
        multiplierPanelVisible = !multiplierPanelVisible;
        panel.classList.toggle('hidden', !multiplierPanelVisible);
        if (multiplierPanelVisible) {
            fishDetailVisible = false;
            document.getElementById('fish-detail-panel').classList.add('hidden');
            backdrop.classList.add('active');
        } else {
            backdrop.classList.remove('active');
            return;
        }

        const streakSec = streakActive ? Math.floor((performance.now() - streakStart) / 1000) : 0;
        const tiers = [
            { threshold: 30, label: '√ó1.5', time: '30s' },
            { threshold: 90, label: '√ó2', time: '90s' },
            { threshold: 180, label: '√ó3', time: '3min' }
        ];

        let html = `<div class="multiplier-detail-title">Score Multiplier</div>`;
        html += `<div class="multiplier-detail-value">√ó${multiplier}</div>`;
        if (streakActive) {
            html += `<div class="multiplier-detail-desc">All fish healthy for ${streakSec}s</div>`;
        } else {
            html += `<div class="multiplier-detail-desc">Keep all fish above 80% health to build a streak</div>`;
        }
        html += `<div style="margin-top:8px;">`;
        tiers.forEach(t => {
            const isCurrent = multiplier >= parseFloat(t.label.replace('√ó', ''));
            html += `<div class="multiplier-tier${isCurrent ? ' current' : ''}">`
                + `<span>${t.label}</span><span>${t.time} streak</span></div>`;
        });
        html += `</div>`;
        detail.innerHTML = html;
    }

    function showStatus(message) {
        statusQueue.push(message);
        // Drop older messages if queue is backing up
        if (statusQueue.length > 4) {
            statusQueue.splice(0, statusQueue.length - 3);
        }
        if (!statusTimer) processStatusQueue();
    }

    function processStatusQueue() {
        if (statusQueue.length === 0) {
            statusTimer = null;
            // Fade out the last message
            const el = document.getElementById('status-line');
            if (el) el.style.opacity = '0';
            return;
        }
        const msg = statusQueue.shift();
        const el = document.getElementById('status-line');
        if (el) {
            el.style.opacity = '0';
            setTimeout(() => {
                el.textContent = msg;
                el.style.opacity = '1';
            }, 150);
        }
        // Shorter display when messages are queued, normal when caught up
        const displayTime = statusQueue.length > 0 ? 1200 : 2500;
        statusTimer = setTimeout(processStatusQueue, displayTime);
    }

    function updateButtonStates(score, feedCost, cleanCost, buyCost, isPaused) {
        const btnFeed = document.getElementById('btn-feed');
        const btnClean = document.getElementById('btn-clean');
        const btnBuy = document.getElementById('btn-buy');
        const btnPause = document.getElementById('btn-pause');

        if (btnFeed) btnFeed.disabled = score < feedCost || isPaused;
        if (btnClean) btnClean.disabled = score < cleanCost || isPaused;
        if (btnBuy) btnBuy.disabled = score < buyCost || isPaused;
        if (btnPause) {
            btnPause.querySelector('.ctrl-icon').textContent = isPaused ? '‚ñ∂' : '‚è∏';
            btnPause.querySelector('.ctrl-label').textContent = isPaused ? 'Resume' : 'Pause';
        }
    }

    function populateFishShop(fishTypes, score, onBuy) {
        const shop = document.getElementById('fish-shop');
        if (!shop) return;
        shop.innerHTML = '';

        fishTypes.forEach(type => {
            const item = Utils.htmlEl('div', 'shop-item');
            if (score < type.cost) item.classList.add('disabled');

            // Fish preview SVG
            const preview = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            preview.setAttribute('class', 'shop-fish-preview');
            preview.setAttribute('viewBox', '-30 -20 60 40');
            const isInk = type.inkStyle || false;
            const body = Utils.svgEl('ellipse', {
                cx: 0, cy: 0, rx: 18, ry: 10,
                fill: isInk ? (type.inkWash || 'none') : type.bodyColor,
                stroke: isInk ? type.accentColor : 'none',
                'stroke-width': isInk ? '1.5' : '0',
                'stroke-linecap': 'round'
            });
            const tail = Utils.svgEl('path', {
                d: `M -15 0 Q -25 -10, -28 -8 Q -20 0, -28 8 Q -25 10, -15 0 Z`,
                fill: isInk ? (type.inkWash || 'none') : type.finColor,
                stroke: isInk ? type.accentColor : 'none',
                'stroke-width': isInk ? '1.2' : '0',
                opacity: '0.8'
            });
            const eye = Utils.svgEl('circle', {
                cx: 8, cy: -2, r: 2.5,
                fill: isInk ? 'none' : '#fff',
                stroke: isInk ? type.accentColor : 'none',
                'stroke-width': isInk ? '1' : '0'
            });
            preview.appendChild(tail);
            preview.appendChild(body);
            preview.appendChild(eye);
            item.appendChild(preview);

            const info = Utils.htmlEl('div', 'shop-fish-info');
            info.appendChild(Utils.htmlEl('div', 'shop-fish-name', type.name));
            if (type.personality) {
                info.appendChild(Utils.htmlEl('div', 'shop-fish-personality', type.personality));
            }
            info.appendChild(Utils.htmlEl('div', 'shop-fish-cost', `Cost: ${type.cost}`));
            item.appendChild(info);

            if (score >= type.cost) {
                item.addEventListener('click', () => onBuy(type));
            }

            shop.appendChild(item);
        });
    }

    function showModal(id) {
        document.getElementById(id).classList.remove('hidden');
    }

    function hideModal(id) {
        document.getElementById(id).classList.add('hidden');
    }

    function openFishShopFlyout() {
        const flyout = document.getElementById('fish-shop-flyout');
        const backdrop = document.getElementById('flyout-backdrop');
        if (flyout) flyout.classList.add('open');
        if (backdrop) backdrop.classList.add('active');
    }

    function closeFishShopFlyout() {
        const flyout = document.getElementById('fish-shop-flyout');
        const backdrop = document.getElementById('flyout-backdrop');
        if (flyout) flyout.classList.remove('open');
        if (backdrop) backdrop.classList.remove('active');
    }

    function openVolumeFlyout() {
        const flyout = document.getElementById('volume-flyout');
        const backdrop = document.getElementById('flyout-backdrop');
        if (flyout) flyout.classList.add('open');
        if (backdrop) backdrop.classList.add('active');
    }

    function closeVolumeFlyout() {
        const flyout = document.getElementById('volume-flyout');
        const backdrop = document.getElementById('flyout-backdrop');
        if (flyout) flyout.classList.remove('open');
        if (backdrop) backdrop.classList.remove('active');
    }

    function closeAllFlyouts() {
        closeFishShopFlyout();
        closeVolumeFlyout();
        // Close HUD panels
        fishDetailVisible = false;
        multiplierPanelVisible = false;
        const fp = document.getElementById('fish-detail-panel');
        const mp = document.getElementById('multiplier-panel');
        if (fp) fp.classList.add('hidden');
        if (mp) mp.classList.add('hidden');
        const backdrop = document.getElementById('flyout-backdrop');
        if (backdrop) backdrop.classList.remove('active');
    }

    // Splash screen
    function initSplash(themes, onSelect, onStart) {
        const cards = document.getElementById('theme-cards');
        let selected = null;

        // Create splash bubbles
        const bubblesEl = document.getElementById('splash-bubbles');
        for (let i = 0; i < 15; i++) {
            const b = Utils.htmlEl('div', 'splash-bubble');
            const size = Utils.rand(4, 12);
            b.style.cssText = `
                left: ${Utils.rand(5, 95)}%;
                bottom: -20px;
                width: ${size}px; height: ${size}px;
                animation-duration: ${Utils.rand(6, 15)}s;
                animation-delay: ${Utils.rand(0, 8)}s;
            `;
            bubblesEl.appendChild(b);
        }

        // Create splash kelp strands
        const kelpPalette = [
            { stipe: '#3d2b1a', blade: '#2d5a2a', bulb: '#4a7a3a' },
            { stipe: '#4a3520', blade: '#3a6830', bulb: '#5a8840' },
            { stipe: '#352818', blade: '#2a4e22', bulb: '#3d6830' },
            { stipe: '#503a25', blade: '#4a7040', bulb: '#6a9050' },
            { stipe: '#3a2c1a', blade: '#355e2e', bulb: '#4e7a38' }
        ];
        ['splash-seaweed-left', 'splash-seaweed-right'].forEach(containerId => {
            const container = document.getElementById(containerId);
            const strandCount = Utils.randInt(3, 5);
            for (let si = 0; si < strandCount; si++) {
                const colors = Utils.pick(kelpPalette);
                const stipe = Utils.htmlEl('div', 'kelp-stipe');
                const h = Utils.rand(150, 320);
                const x = Utils.rand(5, 70);
                const swayDur = Utils.rand(5, 10);
                const swayDelay = Utils.rand(0, 4);
                stipe.style.cssText = `
                    left: ${x}px; height: ${h}px;
                    background: linear-gradient(to top, ${colors.stipe}, ${colors.stipe}cc);
                    animation-duration: ${swayDur}s;
                    animation-delay: ${swayDelay}s;
                    opacity: ${Utils.rand(0.5, 0.8).toFixed(2)};
                `;
                // Add kelp blades along the stipe
                const bladeCount = Utils.randInt(3, 6);
                for (let bi = 0; bi < bladeCount; bi++) {
                    const blade = Utils.htmlEl('div', 'kelp-blade');
                    const isLeft = Math.random() > 0.5;
                    blade.classList.add(isLeft ? 'left-blade' : 'right-blade');
                    const bladeY = ((bi + 0.5) / bladeCount) * h;
                    const bladeW = Utils.rand(20, 40);
                    const bladeH = Utils.rand(8, 16);
                    blade.style.cssText = `
                        bottom: ${bladeY}px;
                        ${isLeft ? 'right' : 'left'}: 2px;
                        width: ${bladeW}px; height: ${bladeH}px;
                        background: linear-gradient(${isLeft ? 'to left' : 'to right'}, ${colors.blade}cc, ${colors.blade}44);
                        animation-duration: ${Utils.rand(4, 8)}s;
                        animation-delay: ${Utils.rand(0, 3)}s;
                        opacity: ${Utils.rand(0.5, 0.8).toFixed(2)};
                    `;
                    stipe.appendChild(blade);
                }
                // Add gas bladder (bulb) near top
                const bulb = Utils.htmlEl('div', 'kelp-bulb');
                bulb.style.cssText = `
                    top: -4px; left: -1px;
                    background: radial-gradient(circle at 40% 40%, ${colors.bulb}, ${colors.blade});
                    opacity: ${Utils.rand(0.5, 0.7).toFixed(2)};
                `;
                stipe.appendChild(bulb);
                container.appendChild(stipe);
            }
        });

        themes.forEach(t => {
            const card = Utils.htmlEl('div', 'theme-card');
            card.style.background = t.cardBg;
            card.innerHTML = `
                <div class="theme-card-name">${t.name}</div>
                <div class="theme-card-desc">${t.description}</div>
            `;
            card.addEventListener('click', () => {
                document.querySelectorAll('.theme-card').forEach(c => c.classList.remove('selected'));
                card.classList.add('selected');
                selected = t.id;
                onSelect(t.id);
                onStart(t.id);
            });
            cards.appendChild(card);
        });

        // About overlay
        document.getElementById('about-btn').addEventListener('click', () => {
            document.getElementById('about-overlay').classList.add('visible');
        });
        document.getElementById('about-close').addEventListener('click', () => {
            document.getElementById('about-overlay').classList.remove('visible');
        });
        document.getElementById('about-overlay').addEventListener('click', (e) => {
            if (e.target === e.currentTarget) {
                e.currentTarget.classList.remove('visible');
            }
        });

        // Splash screen ambient sound + mute button
        let splashMuted = false;
        const muteBtn = document.getElementById('splash-mute-btn');

        // Start splash audio on first user interaction (required by browsers)
        const startSplashOnce = () => {
            if (!splashMuted) {
                ZenAudio.startSplashAmbient();
            }
            document.removeEventListener('click', startSplashOnce);
            document.removeEventListener('keydown', startSplashOnce);
        };
        document.addEventListener('click', startSplashOnce);
        document.addEventListener('keydown', startSplashOnce);

        muteBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            splashMuted = !splashMuted;
            muteBtn.textContent = splashMuted ? 'üîá' : 'üîä';
            if (splashMuted) {
                ZenAudio.stopSplashAmbient();
            } else {
                ZenAudio.startSplashAmbient();
            }
        });
    }

    function hideSplash(onVisible) {
        ZenAudio.stopSplashAmbient();
        const splash = document.getElementById('splash-screen');
        splash.classList.add('fade-out');
        setTimeout(() => {
            splash.classList.add('hidden');
            document.getElementById('game-screen').classList.remove('hidden');
            if (onVisible) requestAnimationFrame(() => onVisible());
        }, 1000);
    }

    function showSplash() {
        const splash = document.getElementById('splash-screen');
        splash.classList.remove('hidden', 'fade-out');
        document.getElementById('game-screen').classList.add('hidden');
        // Update stats ribbon
        updateStatsRibbon();
        // Restart splash ambient if not muted
        const muteBtn = document.getElementById('splash-mute-btn');
        if (muteBtn && muteBtn.textContent !== 'üîá') {
            ZenAudio.startSplashAmbient();
        }
    }

    function updateStatsRibbon() {
        const d = ZenStorage.get();
        const hs = document.getElementById('ribbon-high-score');
        const sess = document.getElementById('ribbon-sessions');
        const ach = document.getElementById('ribbon-achievements');
        const total = document.getElementById('ribbon-total-achievements');
        if (hs) hs.textContent = d.highScore.toLocaleString();
        if (sess) sess.textContent = d.totalSessions.toString();
        if (ach) ach.textContent = d.achievements.length.toString();
        if (total) total.textContent = Achievements.defs.length.toString();
        const ribbonMilestone = document.getElementById('ribbon-best-milestone');
        if (ribbonMilestone) {
            const bm = d.bestMilestone;
            if (bm) {
                const mDef = [{id:'bronze',icon:'ü•â',title:'Bronze'},{id:'silver',icon:'ü•à',title:'Silver'},{id:'gold',icon:'ü•á',title:'Gold'},{id:'master',icon:'üèÜ',title:'Master'}].find(m => m.id === bm);
                ribbonMilestone.textContent = mDef ? `${mDef.icon} ${mDef.title}` : '';
            } else {
                ribbonMilestone.textContent = '';
            }
        }
    }

    function showSessionSummary(score, onContinue, defeatCause, victoryCause) {
        const d = ZenStorage.get();
        const isNewHigh = ZenStorage.updateHighScore(score);
        const duration = Achievements.getSessionDuration();
        const sd = Achievements.getSessionData();

        document.getElementById('summary-score').textContent = Math.round(score).toLocaleString();
        document.getElementById('summary-best').textContent = d.highScore.toLocaleString();
        document.getElementById('summary-duration').textContent = formatDuration(duration);
        document.getElementById('summary-born').textContent = sd.fishBorn.toString();
        document.getElementById('summary-lost').textContent = sd.fishLost.toString();
        document.getElementById('summary-peak').textContent = sd.peakFishCount.toString();

        const badge = document.getElementById('high-score-badge');
        badge.style.display = isNewHigh ? 'block' : 'none';

        // Show defeat or victory cause
        const defeatEl = document.getElementById('defeat-cause');
        const victoryEl = document.getElementById('victory-cause');
        if (defeatCause) {
            defeatEl.textContent = defeatCause;
            defeatEl.style.display = 'block';
            victoryEl.style.display = 'none';
        } else if (victoryCause) {
            victoryEl.textContent = victoryCause;
            victoryEl.style.display = 'block';
            defeatEl.style.display = 'none';
        } else {
            defeatEl.style.display = 'none';
            victoryEl.style.display = 'none';
        }

        // Show best milestone under Best Score
        const bestMilestoneEl = document.getElementById('summary-best-milestone');
        if (bestMilestoneEl) {
            const bm = d.bestMilestone;
            if (bm) {
                const mDef = [{id:'bronze',icon:'ü•â',title:'Bronze Aquarist'},{id:'silver',icon:'ü•à',title:'Silver Aquarist'},{id:'gold',icon:'ü•á',title:'Gold Aquarist'},{id:'master',icon:'üèÜ',title:'Master Aquarist'}].find(m => m.id === bm);
                bestMilestoneEl.textContent = mDef ? `${mDef.icon} ${mDef.title}` : '';
            } else {
                bestMilestoneEl.textContent = '';
            }
        }

        // Show achievements earned this session
        const achDiv = document.getElementById('summary-achievements');
        if (sd.newAchievements.length > 0) {
            const achDefs = Achievements.getDefs();
            achDiv.innerHTML = '<div style="margin-bottom:6px;font-size:0.65rem;text-transform:uppercase;letter-spacing:0.1em">Achievements Earned</div>' +
                sd.newAchievements.map(id => {
                    const def = achDefs.find(a => a.id === id);
                    return def ? `<span class="achievement-earned">${def.icon} ${def.name}</span>` : '';
                }).join('');
        } else {
            achDiv.innerHTML = '';
        }

        // Update session stats
        ZenStorage.setStatMax('longestSession', Math.round(duration));
        ZenStorage.incrementSessions();

        const overlay = document.getElementById('session-summary');
        overlay.classList.add('visible');

        const btn = document.getElementById('summary-continue');
        const handler = () => {
            btn.removeEventListener('click', handler);
            overlay.classList.remove('visible');
            if (onContinue) onContinue();
        };
        btn.addEventListener('click', handler);
    }

    function formatDuration(seconds) {
        const m = Math.floor(seconds / 60);
        const s = Math.floor(seconds % 60);
        return `${m}:${s.toString().padStart(2, '0')}`;
    }

    function showAchievementsOverlay() {
        const grid = document.getElementById('achievements-grid');
        const d = ZenStorage.get();
        const defs = Achievements.getDefs();
        grid.innerHTML = '';

        defs.forEach(def => {
            const unlocked = d.achievements.includes(def.id);
            const card = document.createElement('div');
            card.className = `achievement-card ${unlocked ? 'unlocked' : 'locked'}`;
            const dateStr = unlocked && d.achievementDates[def.id] ? d.achievementDates[def.id] : '';
            card.innerHTML = `
                <div class="ach-icon">${unlocked ? def.icon : 'üîí'}</div>
                <div class="ach-name">${def.name}</div>
                <div class="ach-desc">${unlocked ? def.desc : def.desc}</div>
                ${dateStr ? `<div class="ach-date">Earned ${dateStr}</div>` : ''}
            `;
            grid.appendChild(card);
        });

        document.getElementById('achievements-overlay').classList.add('visible');
    }

    function hideAchievementsOverlay() {
        document.getElementById('achievements-overlay').classList.remove('visible');
    }

    return {
        init, updateScore, updateHealth, updateFishCount,
        updateFishDetail, updateMultiplier, toggleMultiplierPanel, showStatus, updateButtonStates,
        populateFishShop, showModal, hideModal, openFishShopFlyout, closeFishShopFlyout, openVolumeFlyout, closeVolumeFlyout, closeAllFlyouts,
        initSplash, hideSplash, showSplash,
        updateStatsRibbon, showSessionSummary,
        showAchievementsOverlay, hideAchievementsOverlay
    };
})();


/* ============================================
   ZENQUARIUM - Main Application
   ============================================ */

const App = (() => {
    // Game state
    let state = {
        score: 100,
        tankHealth: 100,
        cleanlinessDecay: 0,
        fish: [],
        theme: null,
        themeId: 'koi',
        isPaused: false,
        isRunning: false,
        maxFish: 20,
        feedCost: 5,
        cleanCost: 10,
        buyCost: 20,
        scoreRate: 0.5, // per second per healthy fish
        lastTime: 0,
        reproductionCooldowns: {},
        autoMode: false,
        autoFeedTimer: 0,
        autoCleanTimer: 0,
        autoBuyTimer: 0,
        tapCooldown: 0,
        tapStressAccum: 0,
        mouseX: -1,
        mouseY: -1,
        multiplier: 1,
        streakStart: 0,
        streakActive: false,
        lastMultiplierLevel: 1,
        perfectTankTimer: 0,
        biodiversityTimer: 0,
        neglectTimer: 0,
        gameOverTimer: 0,
        gameOverWarning: false,
        gameOverTriggered: false,
        milestonesShown: new Set(),
        thrivingTimer: 0,
        pendingMilestone: null
    };

    let fishLayer = null;
    let animFrameId = null;

    function scoreEvent(amount, message) {
        state.score = Math.max(0, state.score + amount);
        UI.showStatus(message);
    }

    function init() {
        // Initialize persistent storage
        ZenStorage.load();
        UI.updateStatsRibbon();

        // Setup splash screen
        UI.initSplash(
            Themes.getAllThemes(),
            onThemePreview,
            onGameStart
        );

        // Achievements overlay button
        document.getElementById('achievements-btn').addEventListener('click', () => {
            UI.showAchievementsOverlay();
        });
        document.getElementById('achievements-close').addEventListener('click', () => {
            UI.hideAchievementsOverlay();
        });
        document.getElementById('achievements-overlay').addEventListener('click', (e) => {
            if (e.target === document.getElementById('achievements-overlay')) {
                UI.hideAchievementsOverlay();
            }
        });

        // Hidden reset: triple-click achievements title
        document.getElementById('achievements-title').addEventListener('click', (e) => {
            if (e.detail === 3) {
                const d = ZenStorage.get();
                d.achievements = [];
                d.achievementDates = {};
                d.themesPlayed = [];
                ZenStorage.save();
                UI.showAchievementsOverlay();
                UI.updateStatsRibbon();
            }
        });

        // Track mouse position for curious fish behavior
        document.addEventListener('mousemove', (e) => {
            const tank = document.getElementById('tank');
            if (tank) {
                const rect = tank.getBoundingClientRect();
                state.mouseX = e.clientX - rect.left;
                state.mouseY = e.clientY - rect.top;
            }
        });
    }

    function onThemePreview(themeId) {
        state.themeId = themeId;
    }

    function onGameStart(themeId) {
        state.themeId = themeId;
        state.theme = Themes.applyTheme(themeId);
        Achievements.resetSession();
        ZenStorage.recordTheme(themeId);

        // Init audio (needs user gesture)
        ZenAudio.ensureCtx();

        UI.hideSplash(() => {
            setupGame();
        });
    }

    let controlsBound = false;

    function setupGame() {
        fishLayer = document.getElementById('fish-layer');

        Tank.init(state.theme);
        const { w, h } = getSize();
        Food.init(w, h);
        Creatures.init(w, h, state.themeId);
        UI.init();

        // Scale max fish for tank size (reference: 1200√ó800 = 20 fish, floor at 15)
        state.maxFish = calcMaxFish(w, h);

        // Start with 2 fish
        const startTypes = state.theme.fishTypes.slice(0, 2);
        startTypes.forEach(type => {
            addFish(type);
        });

        // Bind controls only once
        if (!controlsBound) {
            bindControls();
            controlsBound = true;
        }

        // Start game loop
        state.isRunning = true;
        state.lastTime = performance.now();
        ZenAudio.startAmbient(state.themeId);
        gameLoop(performance.now());

        UI.showStatus('Your aquarium awaits. Add fish and keep them happy!');
    }

    function getSize() {
        Tank.updateSize();
        return Tank.getSize();
    }

    function calcMaxFish(w, h) {
        const refArea = 1200 * 800;
        const ratio = (w * h) / refArea;
        return Math.max(15, Math.min(20, Math.round(20 * ratio)));
    }

    function bindControls() {
        document.getElementById('btn-feed').addEventListener('click', onFeed);
        document.getElementById('btn-clean').addEventListener('click', onClean);
        document.getElementById('btn-buy').addEventListener('click', () => {
            UI.closeVolumeFlyout();
            UI.populateFishShop(state.theme.fishTypes, state.score, onBuyFish);
            UI.openFishShopFlyout();
        });
        document.getElementById('btn-pause').addEventListener('click', onPause);
        document.getElementById('btn-restart').addEventListener('click', onRestart);
        document.getElementById('flyout-backdrop').addEventListener('click', () => {
            UI.closeAllFlyouts();
        });
        document.getElementById('volume-slider').addEventListener('input', (e) => {
            const vol = e.target.value / 100;
            ZenAudio.setVolume(vol);
            document.getElementById('volume-icon-display').textContent = vol === 0 ? 'üîá' : 'üîä';
        });

        // Volume flyout toggle
        document.getElementById('btn-volume').addEventListener('click', () => {
            const flyout = document.getElementById('volume-flyout');
            if (flyout.classList.contains('open')) {
                UI.closeVolumeFlyout();
            } else {
                UI.closeFishShopFlyout();
                UI.openVolumeFlyout();
            }
        });

        // Restart confirmation modal buttons
        document.getElementById('restart-confirm').addEventListener('click', doRestart);
        document.getElementById('restart-cancel').addEventListener('click', () => {
            document.getElementById('restart-modal').classList.add('hidden');
        });
        document.getElementById('restart-modal').addEventListener('click', (e) => {
            if (e.target === e.currentTarget) {
                document.getElementById('restart-modal').classList.add('hidden');
            }
        });

        // Milestone modal buttons
        document.getElementById('milestone-continue').addEventListener('click', () => {
            document.getElementById('milestone-modal').classList.add('hidden');
            state.isPaused = false;
            state.lastTime = performance.now();
        });
        document.getElementById('milestone-end').addEventListener('click', () => {
            // Find the highest milestone reached this session
            let best = null;
            for (const m of milestones) {
                if (state.milestonesShown.has(m.id)) best = m;
            }
            if (best) endWithVictory(best);
        });

        // Controls chevron toggle
        document.getElementById('controls-chevron').addEventListener('click', () => {
            const wrapper = document.getElementById('controls-wrapper');
            const isCollapsed = wrapper.classList.toggle('collapsed');
            if (isCollapsed) UI.closeAllFlyouts();
            // On small screens, also toggle HUD visibility
            const hud = document.getElementById('hud');
            if (window.innerWidth <= 768) {
                hud.classList.toggle('hud-minimized', isCollapsed);
            }
        });

        // Auto mode toggle
        document.getElementById('auto-toggle').addEventListener('change', (e) => {
            state.autoMode = e.target.checked;
            UI.showStatus(state.autoMode ? 'Zen mode enabled üßò' : 'Zen mode disabled');
        });

        // Click tank ‚Äî tap the glass or drop food
        document.getElementById('tank').addEventListener('click', (e) => {
            if (state.isPaused) return;
            if (e.target.closest('.controls-wrapper') || e.target.closest('.hud') || e.target.closest('.modal')) return;

            const rect = document.getElementById('tank').getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;

            // Check if tapping near a creature first
            const creatureResult = Creatures.handleTap(clickX, clickY, state);
            if (creatureResult) {
                if (creatureResult === 'stingers') {
                    Achievements.onStingersReleased(state.fish.filter(f => f.alive).length);
                    UI.showStatus('ü™º The jellyfish released its stingers! Watch out!');
                } else if (creatureResult === 'octopus-ink') {
                    Achievements.onInkSquirted(state.fish.filter(f => f.alive).length);
                    UI.showStatus('üêô The octopus squirted ink everywhere! üí®');
                } else if (creatureResult === 'squid-ink') {
                    Achievements.onInkSquirted(state.fish.filter(f => f.alive).length);
                    UI.showStatus('ü¶ë The squid blasted glowing ink! üíö');
                } else {
                    UI.showStatus('The creature darts away! üåä');
                }
                // Ripple effect at click
                const rippleSize = 100;
                const ripple = document.createElement('div');
                ripple.className = 'tap-ripple';
                ripple.style.cssText = `left:${clickX - rippleSize/2}px; top:${clickY - rippleSize/2}px; width:${rippleSize}px; height:${rippleSize}px;`;
                document.getElementById('tank').appendChild(ripple);
                setTimeout(() => ripple.remove(), 600);
                return;
            }

            // Check if any fish are near the click ‚Äî use fish size for better hit detection
            const baseScatterRadius = 150;
            let nearbyFish = state.fish.filter(f => {
                if (!f.alive) return false;
                const fishRadius = baseScatterRadius + f.size * 30;
                return Utils.dist(f.x, f.y, clickX, clickY) < fishRadius;
            });

            if (nearbyFish.length > 0) {
                // Tap the glass ‚Äî scatter nearby fish dramatically
                const crowdIntensity = Math.min(nearbyFish.length / 3, 2);
                nearbyFish.forEach(f => {
                    const bravery = f.hasTrait('brave');
                    const curiosity = f.hasTrait('curious');
                    // Curious fish swim TOWARD the tap; brave fish flee less
                    let fleeAngle;
                    if (curiosity && Math.random() < 0.5 * curiosity) {
                        // Curious: approach the tap point instead of fleeing
                        fleeAngle = Math.atan2(clickY - f.y, clickX - f.x) + Utils.rand(-0.2, 0.2);
                        const approachDist = Utils.rand(60, 120);
                        f.targetX = Utils.clamp(f.x + Math.cos(fleeAngle) * approachDist, 60, f.tankW - 60);
                        f.targetY = Utils.clamp(f.y + Math.sin(fleeAngle) * approachDist, 60, f.tankH - 100);
                        f.speed = f.baseSpeed * Utils.rand(2, 3);
                    } else {
                        fleeAngle = Math.atan2(f.y - clickY, f.x - clickX) + Utils.rand(-0.3, 0.3);
                        const braveMult = bravery ? (1 - bravery * 0.35) : 1;
                        const fleeDist = Utils.rand(250, 500) * (1 + crowdIntensity * 0.4) * braveMult;
                        f.targetX = Utils.clamp(f.x + Math.cos(fleeAngle) * fleeDist, 60, f.tankW - 60);
                        f.targetY = Utils.clamp(f.y + Math.sin(fleeAngle) * fleeDist * 0.6, 60, f.tankH - 100);
                        const speedMult = bravery ? Utils.rand(3, 5) : Utils.rand(6, 10);
                        f.speed = f.baseSpeed * speedMult * (1 + crowdIntensity * 0.3);
                    }
                    const burstSpeed = f.speed * 60 * 0.016;
                    f.vx = Math.cos(fleeAngle) * burstSpeed;
                    f.vy = Math.sin(fleeAngle) * burstSpeed * 0.6;
                    f.dartCooldown = Utils.rand(1.0, 2.0);
                    f.nextTargetTime = performance.now() + Utils.rand(1500, 3000);
                });

                // Glass tap sound effect ‚Äî intensity scales with fish count
                ZenAudio.playTapGlass(Math.min(0.6 + crowdIntensity * 0.3, 1.2));

                // Visual ripple effect ‚Äî larger when more fish scatter
                const rippleSize = 80 + nearbyFish.length * 15;
                const ripple = document.createElement('div');
                ripple.className = 'tap-ripple';
                ripple.style.cssText = `left:${clickX - rippleSize/2}px; top:${clickY - rippleSize/2}px; width:${rippleSize}px; height:${rippleSize}px;`;
                document.getElementById('tank').appendChild(ripple);
                setTimeout(() => ripple.remove(), 600);

                // Second ripple ring for dramatic effect when many fish
                if (nearbyFish.length >= 3) {
                    setTimeout(() => {
                        const r2 = document.createElement('div');
                        r2.className = 'tap-ripple';
                        const s2 = rippleSize * 1.4;
                        r2.style.cssText = `left:${clickX - s2/2}px; top:${clickY - s2/2}px; width:${s2}px; height:${s2}px;`;
                        document.getElementById('tank').appendChild(r2);
                        setTimeout(() => r2.remove(), 600);
                    }, 100);
                }

                // Tapping stress ‚Äî accumulates and hurts tank health
                state.tapStressAccum += 3;
                Achievements.onGlassTap();
                if (state.tapStressAccum > 10) {
                    state.tankHealth = Math.max(0, state.tankHealth - 2);
                    scoreEvent(-5, 'üò∞ Fish stressed! -5');
                } else {
                    UI.showStatus('*tap tap* Fish scatter! üëÜ');
                }
            } else {
                // No fish nearby ‚Äî drop food as before
                if (state.score >= state.feedCost) {
                    state.score -= state.feedCost;
                    Food.dropFood(Utils.randInt(3, 6));
                    ZenAudio.playPlop();
                    UI.showStatus('Food dropped!');
                }
            }
        });

        // Resize handler
        window.addEventListener('resize', Utils.debounce(() => {
            const { w, h } = getSize();
            Tank.syncSvgSizes();
            Food.resize(w, h);
            Creatures.resize(w, h);
            state.fish.forEach(f => f.resize(w, h));
            state.maxFish = calcMaxFish(w, h);
        }, 200));
    }

    function onFeed() {
        if (state.score < state.feedCost || state.isPaused) return;
        state.score -= state.feedCost;
        const count = Utils.randInt(4, 8);
        Food.dropFood(count);
        Achievements.onFoodDropped(count);
        ZenAudio.playPlop();
        UI.showStatus('Feeding time! üçΩ');
    }

    function onClean() {
        if (state.score < state.cleanCost || state.isPaused) return;
        state.score -= state.cleanCost;
        state.cleanlinessDecay = 0;
        state.tankHealth = Math.min(100, state.tankHealth + 30);
        Achievements.onClean();
        ZenAudio.playCleaning();
        if (state.tankHealth > 70) {
            scoreEvent(20, 'üßπ Clean sweep! +20');
        } else {
            UI.showStatus('Tank cleaned! ‚ú®');
        }
    }

    function onBuyFish(type) {
        if (state.score < type.cost) return;
        if (state.fish.length >= state.maxFish) {
            UI.showStatus('Tank is full! (20 fish max)');
            return;
        }
        state.score -= type.cost;
        addFish(type);
        UI.showStatus(`Added a ${type.name} to the tank!`);
        // Refresh shop to update affordability
        UI.populateFishShop(state.theme.fishTypes, state.score, onBuyFish);
    }

    function addFish(typeInfo, isBaby = false) {
        const { w, h } = getSize();
        const fish = FishFactory.create(typeInfo, w, h, isBaby);
        state.fish.push(fish);
        fishLayer.appendChild(fish.el);
        return fish;
    }

    function removeFish(fish) {
        const idx = state.fish.indexOf(fish);
        if (idx !== -1) {
            state.fish.splice(idx, 1);
            if (fish.el && fish.el.parentNode) {
                // Death animation: flip, float up, fade out
                const el = fish.el;
                const startX = fish.x;
                const startY = fish.y;
                const startTime = performance.now();
                const duration = 6000;
                function animateDeath(now) {
                    const t = Math.min(1, (now - startTime) / duration);
                    const eased = t * t;
                    const y = startY - eased * 50;
                    const rotate = t * 180;
                    const opacity = 1 - t;
                    const sizeRatio = fish.isBaby ? 0.3 + fish.growthProgress * 0.7 : 1;
                    const scaleX = fish.facingRight ? sizeRatio : -sizeRatio;
                    el.setAttribute('transform',
                        `translate(${startX + Math.sin(t * 6) * 8}, ${y}) scale(${scaleX}, ${sizeRatio}) rotate(${rotate})`);
                    el.style.opacity = opacity;
                    if (t < 1) {
                        requestAnimationFrame(animateDeath);
                    } else {
                        el.remove();
                    }
                }
                requestAnimationFrame(animateDeath);
            }
        }
    }

    function onPause() {
        state.isPaused = !state.isPaused;
        UI.closeAllFlyouts();
        if (state.isPaused) {
            ZenAudio.pause();
            UI.showStatus('Game paused');
        } else {
            ZenAudio.resume();
            state.lastTime = performance.now();
            UI.showStatus('Game resumed');
        }
    }

    function onRestart() {
        UI.closeAllFlyouts();
        // Show styled restart confirmation modal
        document.getElementById('restart-modal').classList.remove('hidden');
    }

    function doRestart() {
        document.getElementById('restart-modal').classList.add('hidden');

        // Stop game loop
        if (animFrameId) cancelAnimationFrame(animFrameId);
        animFrameId = null;
        state.isRunning = false;

        // Capture score before reset
        const finalScore = state.score;

        // Clear everything
        state.fish.forEach(f => { if (f.el && f.el.parentNode) f.el.remove(); });
        state.fish = [];
        Food.clear();
        Creatures.clear();

        ZenAudio.stopAmbient();

        // Check end-of-session achievements
        Achievements.onSessionEnd();

        // Show session summary, then proceed to splash
        UI.showSessionSummary(finalScore, () => {
            state.score = 100;
            state.tankHealth = 100;
            state.cleanlinessDecay = 0;
            state.isPaused = false;
            state.reproductionCooldowns = {};
            state.autoMode = false;
            state.autoFeedTimer = 0;
            state.autoCleanTimer = 0;
            state.autoBuyTimer = 0;
            state.tapStressAccum = 0;
            state.multiplier = 1;
            state.streakStart = 0;
            state.streakActive = false;
            state.lastMultiplierLevel = 1;
            state.perfectTankTimer = 0;
            state.biodiversityTimer = 0;
            state.neglectTimer = 0;
            state.gameOverTimer = 0;
            state.gameOverWarning = false;
            state.gameOverTriggered = false;
            state.milestonesShown = new Set();
            state.thrivingTimer = 0;
            state.pendingMilestone = null;

            // Reset auto toggle UI
            const autoToggle = document.getElementById('auto-toggle');
            if (autoToggle) autoToggle.checked = false;

            // Reset controls bar visibility
            document.getElementById('controls-wrapper').classList.remove('collapsed');
            document.getElementById('hud').classList.remove('hud-minimized');

            // Reset cloudiness overlay
            const cloudinessEl = document.getElementById('tank-cloudiness');
            if (cloudinessEl) cloudinessEl.style.opacity = '0';

            // Reset theme class so splash screen renders correctly
            document.body.className = '';

            // Go back to splash screen
            UI.showSplash();
        });
    }

    function endGame(defeatCause) {
        if (state.gameOverTriggered) return;
        state.gameOverTriggered = true;

        // Stop game loop
        if (animFrameId) cancelAnimationFrame(animFrameId);
        animFrameId = null;
        state.isRunning = false;

        const finalScore = state.score;

        // Show defeat message for 3 seconds, then summary
        UI.showStatus(defeatCause);
        ZenAudio.stopAmbient();
        Achievements.onSessionEnd();

        setTimeout(() => {
            // Clear everything
            state.fish.forEach(f => { if (f.el && f.el.parentNode) f.el.remove(); });
            state.fish = [];
            Food.clear();
            Creatures.clear();

            UI.showSessionSummary(finalScore, () => {
                state.score = 100;
                state.tankHealth = 100;
                state.cleanlinessDecay = 0;
                state.isPaused = false;
                state.reproductionCooldowns = {};
                state.autoMode = false;
                state.autoFeedTimer = 0;
                state.autoCleanTimer = 0;
                state.autoBuyTimer = 0;
                state.tapStressAccum = 0;
                state.multiplier = 1;
                state.streakStart = 0;
                state.streakActive = false;
                state.lastMultiplierLevel = 1;
                state.perfectTankTimer = 0;
                state.biodiversityTimer = 0;
                state.neglectTimer = 0;
                state.gameOverTimer = 0;
                state.gameOverWarning = false;
                state.gameOverTriggered = false;
                state.milestonesShown = new Set();
                state.thrivingTimer = 0;
                state.pendingMilestone = null;

                const autoToggle = document.getElementById('auto-toggle');
                if (autoToggle) autoToggle.checked = false;
                document.getElementById('controls-wrapper').classList.remove('collapsed');
                document.getElementById('hud').classList.remove('hud-minimized');
                const cloudinessEl = document.getElementById('tank-cloudiness');
                if (cloudinessEl) cloudinessEl.style.opacity = '0';
                document.body.className = '';
                UI.showSplash();
            }, defeatCause);
        }, 3000);
    }

    // Milestone definitions
    const milestones = [
        { id: 'bronze',  score: 1000,  icon: 'ü•â', title: 'Bronze Aquarist',  msg: "You've reached 1,000 points!" },
        { id: 'silver',  score: 5000,  icon: 'ü•à', title: 'Silver Aquarist',  msg: "You've reached 5,000 points!" },
        { id: 'gold',    score: 10000, icon: 'ü•á', title: 'Gold Aquarist',    msg: "You've reached 10,000 points!" },
        { id: 'master',  score: 0,     icon: 'üèÜ', title: 'Master Aquarist',  msg: 'Your tank is thriving! A true master aquarist.' }
    ];

    function getMilestoneForScore(score) {
        let best = null;
        for (const m of milestones) {
            if (m.score > 0 && score >= m.score) best = m;
        }
        return best;
    }

    function showMilestoneModal(milestone) {
        state.isPaused = true;
        document.getElementById('milestone-icon').textContent = milestone.icon;
        document.getElementById('milestone-title').textContent = milestone.title;
        document.getElementById('milestone-message').textContent = milestone.msg;
        document.getElementById('milestone-modal').classList.remove('hidden');
    }

    function endWithVictory(milestone) {
        document.getElementById('milestone-modal').classList.add('hidden');
        state.isPaused = false;

        if (animFrameId) cancelAnimationFrame(animFrameId);
        animFrameId = null;
        state.isRunning = false;

        const finalScore = state.score;
        const victoryCause = `${milestone.icon} ${milestone.title}`;

        ZenAudio.stopAmbient();
        Achievements.onSessionEnd();

        // Store best milestone
        const d = ZenStorage.get();
        const currentBest = d.bestMilestone || '';
        const rank = milestones.findIndex(m => m.id === milestone.id);
        const prevRank = milestones.findIndex(m => m.id === currentBest);
        if (rank > prevRank) {
            d.bestMilestone = milestone.id;
            ZenStorage.save();
        }

        state.fish.forEach(f => { if (f.el && f.el.parentNode) f.el.remove(); });
        state.fish = [];
        Food.clear();
        Creatures.clear();

        UI.showSessionSummary(finalScore, () => {
            state.score = 100;
            state.tankHealth = 100;
            state.cleanlinessDecay = 0;
            state.isPaused = false;
            state.reproductionCooldowns = {};
            state.autoMode = false;
            state.autoFeedTimer = 0;
            state.autoCleanTimer = 0;
            state.autoBuyTimer = 0;
            state.tapStressAccum = 0;
            state.multiplier = 1;
            state.streakStart = 0;
            state.streakActive = false;
            state.lastMultiplierLevel = 1;
            state.perfectTankTimer = 0;
            state.biodiversityTimer = 0;
            state.neglectTimer = 0;
            state.gameOverTimer = 0;
            state.gameOverWarning = false;
            state.gameOverTriggered = false;
            state.milestonesShown = new Set();
            state.thrivingTimer = 0;
            state.pendingMilestone = null;

            const autoToggle = document.getElementById('auto-toggle');
            if (autoToggle) autoToggle.checked = false;
            document.getElementById('controls-wrapper').classList.remove('collapsed');
            document.getElementById('hud').classList.remove('hud-minimized');
            const cloudinessEl = document.getElementById('tank-cloudiness');
            if (cloudinessEl) cloudinessEl.style.opacity = '0';
            document.body.className = '';
            UI.showSplash();
        }, null, victoryCause);
    }

    // Main game loop
    function gameLoop(timestamp) {
        animFrameId = requestAnimationFrame(gameLoop);

        // Always update button states (so pause label updates)
        UI.updateButtonStates(state.score, state.feedCost, state.cleanCost, state.buyCost, state.isPaused);

        if (state.isPaused) return;

        const dt = Math.min((timestamp - state.lastTime) / 1000, 0.1);
        state.lastTime = timestamp;

        // Update tank environment
        Tank.update(dt);

        // Update food
        Food.update(dt);

        // Update easter egg creatures
        const creatureEaten = Creatures.update(dt, state.fish);

        // Handle fish eaten by creatures
        for (const { fish, creature } of creatureEaten) {
            if (state.fish.includes(fish)) {
                removeFish(fish);
                Achievements.onFishLost();
                ZenAudio.playEaten();
                const icons = { jellyfish: 'ü™º', octopus: 'üêô', squid: 'ü¶ë' };
                const icon = icons[creature.def.type] || 'ü¶ë';
                scoreEvent(-15, `${icon} ${creature.def.name} caught your ${fish.typeName}! -15`);
            }
        }

        // Update fish
        const foods = Food.getAll();
        const deadFish = [];
        const eatenFish = [];

        for (const fish of state.fish) {
            fish._mouseX = state.mouseX;
            fish._mouseY = state.mouseY;
            const prey = fish.update(dt, foods, state.fish);
            if (!fish.alive) {
                deadFish.push(fish);
                if (prey === null) {
                    // Died from starvation/health
                } else {
                    eatenFish.push(fish);
                }
            }
            if (prey && prey !== fish) {
                eatenFish.push(prey);
            }
        }

        // Remove dead fish
        for (const fish of deadFish) {
            removeFish(fish);
            Achievements.onFishLost();
            if (fish.hunger < 10) {
                scoreEvent(-20, `üò¢ ${fish.typeName} starved! -20`);
            } else {
                scoreEvent(-15, `üíÄ ${fish.typeName} lost! -15`);
            }
        }

        for (const fish of eatenFish) {
            if (state.fish.includes(fish)) {
                removeFish(fish);
                Achievements.onFishLost();
                ZenAudio.playEaten();
                scoreEvent(-15, `üíÄ ${fish.typeName} was eaten! -15`);
            }
        }

        // Game over check: all fish lost (with 5-second grace period)
        const aliveFishNow = state.fish.filter(f => f.alive);
        if (aliveFishNow.length === 0 && state.fish.length === 0 && !state.gameOverTriggered) {
            if (!state.gameOverWarning) {
                state.gameOverWarning = true;
                state.gameOverTimer = 5;
                UI.showStatus('‚ö†Ô∏è Your tank is empty! Buy fish before it\'s too late!');
            }
            state.gameOverTimer -= dt;
            if (state.gameOverTimer <= 0) {
                endGame('üíÄ Your last fish has perished...');
                return;
            }
        } else if (state.fish.length > 0) {
            state.gameOverWarning = false;
            state.gameOverTimer = 0;
        }

        // Hunger warning messages (throttled to every 8 seconds)
        if (!state._hungerWarnTime || timestamp - state._hungerWarnTime > 8000) {
            const starving = state.fish.filter(f => f.alive && f.hunger < 20);
            const hungry = state.fish.filter(f => f.alive && f.hunger >= 20 && f.hunger < 35);
            if (starving.length > 0) {
                const name = starving.length === 1 ? `Your ${starving[0].typeName} is` : `${starving.length} fish are`;
                UI.showStatus(`‚ö†Ô∏è ${name} starving! Drop some food!`);
                state._hungerWarnTime = timestamp;
            } else if (hungry.length >= 2) {
                UI.showStatus(`üêü Your fish are getting hungry...`);
                state._hungerWarnTime = timestamp;
            }
            // Predation warning
            const hunters = state.fish.filter(f => f.alive && f.hunger < 20 && f.size > 0.9);
            if (hunters.length > 0 && starving.length > 0) {
                UI.showStatus(`‚ö†Ô∏è Hungry ${hunters[0].typeName} may attack smaller fish!`);
                state._hungerWarnTime = timestamp;
            }
        }

        // Check reproduction
        checkReproduction(dt);

        // Auto mode logic
        if (state.autoMode) {
            updateAutoMode(dt);
        }

        // Tap stress decay over time
        if (state.tapStressAccum > 0) {
            state.tapStressAccum = Math.max(0, state.tapStressAccum - dt * 0.5);
        }

        // Check achievements
        Achievements.check(state);

        // Check milestones (1s delay after threshold to let achievement toasts show first)
        const currentScore = Math.round(state.score);
        for (const m of milestones) {
            if (m.score > 0 && currentScore >= m.score && !state.milestonesShown.has(m.id) && !state.pendingMilestone) {
                state.pendingMilestone = { milestone: m, delay: 1.0 };
                state.milestonesShown.add(m.id);
            }
        }

        // Thriving tank: 15+ fish, all 4 species, for 3 minutes
        const aliveFishForThriving = state.fish.filter(f => f.alive);
        if (aliveFishForThriving.length >= 15 && state.theme && state.theme.fishTypes) {
            const typeIds = state.theme.fishTypes.map(t => t.id);
            const present = new Set(aliveFishForThriving.map(f => f.type));
            if (typeIds.every(id => present.has(id))) {
                state.thrivingTimer += dt;
                if (state.thrivingTimer >= 180 && !state.milestonesShown.has('master') && !state.pendingMilestone) {
                    state.pendingMilestone = { milestone: milestones.find(m => m.id === 'master'), delay: 1.0 };
                    state.milestonesShown.add('master');
                }
            } else {
                state.thrivingTimer = 0;
            }
        } else {
            state.thrivingTimer = 0;
        }

        // Process pending milestone with delay
        if (state.pendingMilestone) {
            state.pendingMilestone.delay -= dt;
            if (state.pendingMilestone.delay <= 0) {
                showMilestoneModal(state.pendingMilestone.milestone);
                state.pendingMilestone = null;
            }
        }

        // Health streak multiplier
        const aliveFish = state.fish.filter(f => f.alive);
        const allHealthy = aliveFish.length > 0 && aliveFish.every(f => f.health > 80);
        const anyLow = aliveFish.some(f => f.health < 50);

        if (allHealthy) {
            if (!state.streakActive) {
                state.streakActive = true;
                state.streakStart = timestamp;
            }
            const streakTime = (timestamp - state.streakStart) / 1000;
            let newMultiplier = 1;
            if (streakTime >= 180) newMultiplier = 3;
            else if (streakTime >= 90) newMultiplier = 2;
            else if (streakTime >= 30) newMultiplier = 1.5;

            if (newMultiplier !== state.lastMultiplierLevel) {
                state.lastMultiplierLevel = newMultiplier;
                if (newMultiplier > 1) {
                    UI.showStatus(`üî• Score multiplier now √ó${newMultiplier}!`);
                }
            }
            state.multiplier = newMultiplier;
        } else if (anyLow && state.multiplier > 1) {
            state.multiplier = 1;
            state.streakActive = false;
            state.lastMultiplierLevel = 1;
            UI.showStatus('üíî Multiplier lost ‚Äî a fish is struggling!');
        } else if (!allHealthy) {
            state.streakActive = false;
            state.lastMultiplierLevel = state.multiplier > 1 ? state.multiplier : 1;
        }

        // Update multiplier badge
        UI.updateMultiplier(state.multiplier);

        // Update score (healthy fish generate score)
        const healthyFish = state.fish.filter(f => f.alive && f.health > 50 && !f.isBaby);
        state.score += healthyFish.length * state.scoreRate * dt * state.multiplier;

        // Repeatable score bonuses
        const aliveFishCount = aliveFish.length;

        // Perfect Tank: +25 every 60s while health >90% and 5+ fish
        state.perfectTankTimer += dt;
        if (state.tankHealth > 90 && aliveFishCount >= 5 && state.perfectTankTimer >= 60) {
            state.perfectTankTimer = 0;
            scoreEvent(25, '‚ú® Perfect tank! +25');
        } else if (state.tankHealth <= 90) {
            state.perfectTankTimer = 0;
        }

        // Biodiversity: +15 every 45s while all 4 species alive
        state.biodiversityTimer += dt;
        if (state.theme && state.theme.fishTypes) {
            const typeIds = state.theme.fishTypes.map(t => t.id);
            const presentTypes = new Set(aliveFish.map(f => f.type));
            const allPresent = typeIds.length > 0 && typeIds.every(id => presentTypes.has(id));
            if (allPresent && state.biodiversityTimer >= 45) {
                state.biodiversityTimer = 0;
                scoreEvent(15, 'üåà Biodiversity! +15');
            } else if (!allPresent) {
                state.biodiversityTimer = 0;
            }
        }

        // Neglected Tank penalty: -10 every 30s while health <25%
        if (state.tankHealth < 25) {
            state.neglectTimer += dt;
            if (state.neglectTimer >= 30) {
                state.neglectTimer = 0;
                scoreEvent(-10, 'üö® Tank neglected! -10');
            }
        } else {
            state.neglectTimer = 0;
        }

        // Tank health decay
        state.cleanlinessDecay += dt * 0.3;
        const overcrowdingPenalty = Math.max(0, state.fish.length - 12) * 0.1;
        state.tankHealth = Math.max(0, 100 - state.cleanlinessDecay - overcrowdingPenalty * state.cleanlinessDecay);

        // Tank health affects fish health
        if (state.tankHealth < 30) {
            state.fish.forEach(f => {
                f.health = Math.max(0, f.health - dt * 2);
            });
        }

        // Game over check: tank health zero
        if (state.tankHealth <= 0 && !state.gameOverTriggered) {
            endGame('üåä The tank has become uninhabitable...');
            return;
        }

        // Update UI
        UI.updateScore(state.score);
        UI.updateHealth(state.tankHealth);
        UI.updateFishCount(state.fish.length, state.maxFish);
        UI.updateButtonStates(state.score, state.feedCost, state.cleanCost, state.buyCost, state.isPaused);

        // Update tank cloudiness based on health
        const cloudinessEl = document.getElementById('tank-cloudiness');
        if (cloudinessEl) {
            const cloudiness = Math.max(0, (70 - state.tankHealth) / 70);
            cloudinessEl.style.opacity = (cloudiness * 0.7).toFixed(3);
        }

        // Update fish detail panel
        const fishByType = {};
        state.fish.forEach(f => {
            if (!fishByType[f.typeName]) {
                fishByType[f.typeName] = { count: 0, color: f.bodyColor };
            }
            fishByType[f.typeName].count++;
        });
        UI.updateFishDetail(fishByType);
    }

    function updateAutoMode(dt) {
        state.autoFeedTimer -= dt;
        state.autoCleanTimer -= dt;
        state.autoBuyTimer -= dt;

        // Auto-feed: check if any fish are hungry
        if (state.autoFeedTimer <= 0) {
            state.autoFeedTimer = 3; // check every 3 seconds
            const hungryFish = state.fish.filter(f => f.alive && f.hunger < 50);
            if (hungryFish.length > 0 && state.score >= state.feedCost) {
                state.score -= state.feedCost;
                Food.dropFood(Utils.randInt(3, 6));
                ZenAudio.playPlop();
            }
        }

        // Auto-clean: clean when tank health drops below 60
        if (state.autoCleanTimer <= 0) {
            state.autoCleanTimer = 5; // check every 5 seconds
            if (state.tankHealth < 60 && state.score >= state.cleanCost) {
                state.score -= state.cleanCost;
                state.cleanlinessDecay = 0;
                state.tankHealth = Math.min(100, state.tankHealth + 30);
                ZenAudio.playCleaning();
            }
        }

        // Auto-buy: maintain population around 5-10 fish
        if (state.autoBuyTimer <= 0) {
            state.autoBuyTimer = 8; // check every 8 seconds
            const aliveFish = state.fish.filter(f => f.alive).length;

            if (aliveFish < 5 && state.fish.length < 10) {
                // Need more fish ‚Äî buy the cheapest affordable type
                const affordable = state.theme.fishTypes
                    .filter(t => t.cost <= state.score)
                    .sort((a, b) => a.cost - b.cost);
                if (affordable.length > 0) {
                    const type = Utils.pick(affordable);
                    state.score -= type.cost;
                    addFish(type);
                    UI.showStatus(`Auto: Added a ${type.name} ü§ñ`);
                }
            }
        }
    }

    function checkReproduction(dt) {
        const maxForReproduction = state.autoMode ? 10 : state.maxFish;
        if (state.fish.length >= maxForReproduction) return;

        // Group adult fish by type
        const adultsByType = {};
        state.fish.forEach(f => {
            if (!f.alive || f.isBaby || f.hunger < 50 || f.health < 60) return;
            if (!adultsByType[f.type]) adultsByType[f.type] = [];
            adultsByType[f.type].push(f);
        });

        for (const [type, adults] of Object.entries(adultsByType)) {
            if (adults.length < 2) continue;

            // Cooldown per type
            if (!state.reproductionCooldowns[type]) {
                state.reproductionCooldowns[type] = 0;
            }
            state.reproductionCooldowns[type] -= dt;
            if (state.reproductionCooldowns[type] > 0) continue;

            // Check if conditions are right
            const avgHunger = adults.reduce((s, f) => s + f.hunger, 0) / adults.length;
            const avgHealth = adults.reduce((s, f) => s + f.health, 0) / adults.length;

            if (avgHunger > 65 && avgHealth > 70 && state.tankHealth > 50) {
                if (Math.random() < 0.02) { // Small chance each frame
                    // Find the type info
                    const typeInfo = state.theme.fishTypes.find(t => t.id === type);
                    if (typeInfo && state.fish.length < state.maxFish) {
                        const baby = addFish(typeInfo, true);
                        // Position near parents
                        const parent = Utils.pick(adults);
                        baby.x = parent.x + Utils.rand(-30, 30);
                        baby.y = parent.y + Utils.rand(-20, 20);
                        baby.updateTransform();

                        ZenAudio.playBirth();
                        Achievements.onFishBorn();
                        scoreEvent(10, `üçº Baby ${typeInfo.name} born! +10`);
                        state.reproductionCooldowns[type] = Utils.rand(20, 40);
                    }
                }
            }
        }
    }

    function getState() { return state; }

    // Start everything
    document.addEventListener('DOMContentLoaded', init);

    return { state, getState, scoreEvent };
})();

    </script>
</body>
</html>